{
  "hash": "6818f98d801f6009cf2416dddcd01053",
  "result": {
    "engine": "knitr",
    "markdown": "---\noutput: html_document\neditor_options: \n  chunk_output_type: console\n---\n\n\n# 함수\n\n## 함수 기본 지식 {#all-about-function}\n\n함수는 입력값(`x`)를 넣어 어떤 작업(`f`)을 수행한 결과를 반환(`y`) 과정으로 이해할 수 있는데, 인자로 다양한 값을 함수에 넣을 수 있고, 물론 함수가 뭔가 유용한 작업을 수행하기 위한 전제조건을 만족시키는지 확인하는 과정을 `assert` 개념을 넣어 확인하고 기술된 작업을 수행한 후에 출력값을 변환시키게 된다.\n\n![데이터 과학 함수 개념](images/function_concept.png)\n\n## 함수 사용법 {#how-to-use-function}\n\n본격적으로 함수를 작성하기 전에 먼저, 함수를 사용하는 방법을 익히는 것이 필요하다.\n함수는 함수명, 인자(argument), 함수 몸통(body), 반환값(return value)으로 구성된다.  \n데이터 과학 대표 언어 R과 파이썬으로 4칙연산을 구현하는 함수를 작성하여 자세히 살펴보자.\n\n### R 함수\n\n- 함수명: 함수명을 먼저 적고 `<-`, `function()`, `{`, `}` 순으로 R이 함수임을 알 수 있도록 전개한다.\n- 함수 인자: 함수에 넣을 인자를 정의하여 넣어 둔다.\n- 함수 몸통(body): 앞서 사칙연산처럼 함수가 수행해야 되는 작업을 기술한다.\n- 반환값(return): `return` 예약어로 함수작업결과 반환되는 값을 명시할 수도 있고, 그냥 놔두면 마지막 객체가 자동으로 반환된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbasic_operation <- function(first, second) {\n  sum_number <- first + second\n  minus_number <- first - second\n  multiply_number <- first * second\n  divide_number <- first / second\n  \n  result <- list(sum_number, minus_number, multiply_number, divide_number)\n  \n  return(result)\n}\n\nbasic_operation(7, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 10\n\n[[2]]\n[1] 4\n\n[[3]]\n[1] 21\n\n[[4]]\n[1] 2.333333\n```\n\n\n:::\n:::\n\n\n### 파이썬 함수\n\n- 함수 머리(header): `def`로 함수임을 선언하고, 함수명과 함수인자를 기술, 마지막을 `:`으로 마무리.\n- 함수 설명: docstring으로 \"\"\" … \"\"\" 으로 함수에 대한 도움말을 기술한다. 함수가 하는 역할, 매개변수, 반환되는 값, 예제 등을 넣어 개발자가 봤을 때 피로도가 없도록 작성한다.\n- 함수 몸통(body): 앞서 사칙연산처럼 함수가 수행해야 되는 작업을 기술한다.\n- 반환값(return): `return` 예약어로 함수작업결과 반환되는 값을 지정한다.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef basic_operation(first, second):\n    \"\"\"\n    숫자 두개를 받아 사칙연산을 수행하는 함수.\n    \n    예제\n        basic_operation(10, 20)\n    매개변수(args)\n        first(int): 정수형 숫자\n        second(int): 정수형 숫자\n    반환값(return)\n        리스트: +-*/ 사칙연산 결과\n    \"\"\"\n    sum_number = first + second\n    minus_number = first - second\n    multiply_number = first * second\n    divide_number = first / second\n    \n    result = [sum_number, minus_number, multiply_number, divide_number]\n    \n    return result\n    \nbasic_operation(7, 3)    \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[10, 4, 21, 2.3333333333333335]\n```\n\n\n:::\n:::\n\n\n\n다른 사람이 작성한 함수를 사용한다는 것은 좀더 엄밀한 의미로 함수를 **호출(call)**한다고 한다.\n함수를 호출해서 다른 사람이 작성한 함수를 사용하기 위해서 먼저 함수명을 알아야 하고, 그 다음으로 함수에서 사용되는 인자(arugment)를 파악해서 올바르게 전달해야 원하는 결과를 얻을 수 있다.\n\n표준편차(`sd`)를 계산하는 `sd` 함수의 경우 전달되는 인자는 두개 `x`, `na.rm = FALSE`인데 이를 확인할 수 있는 명령어가 `args()` 함수다. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nargs(sd)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (x, na.rm = FALSE) \nNULL\n```\n\n\n:::\n:::\n\n\n`x`는 `? sd` 명령어를 통해서 숫자 벡터를 전달해 주어야만 표준편차를 계산할 수 있다.\n예를 들어, 데이터프레임(`penguins`)의 변수 하나(`bill_length_mm`)를 지정하여 전달하고 `na.rm = TRUE`도 명세하여 인자로 전달한다. 인자값이 기본디폴트 값으로 설정된 경우 타이핑을 줄일 수 있고, 결측값이 포함된 경우에 따라서 다른 인자를 넣어 전달하는 방식으로 함수를 사용한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(palmerpenguins)\n\nsd(penguins$bill_length_mm, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.459584\n```\n\n\n:::\n:::\n\n\n\n## 스크립트 &rarr; 함수 {#convert-scripts-to-function}\n\n함수를 작성하는 경우는 먼저 데이터를 가져와서 정제하고 EDA과정을 거치며 모형과 시각화 산출물을 제작하는 과정을 거친다. 그리고 나서 이런 작업이 몇번 반복하게 되면 함수작성을 고려하게 된다. 즉, 스크립트에서 함수로 변환하는 과정을 설명하면 다음과 같다.\n\n1. R 함수 템플릿을 제작한다. \n    - 함수명 <- function() { }\n1. 스크립트를 함수 몸통에 복사하여 붙인다.\n1. 반복작업되는 인자를 찾아내 이를 인자로 넣어둔다.\n1. 인자값과 연동되는 부분을 찾아 맞춰준다.\n1. 함수명을 적절한 동사를 갖춘 이름으로 작명한다.\n1. `return`이 불필요하기 때문에 R 언어 특성을 반영하여 필요한 경우 제거한다.\n\n\n### 주사위 {#writing-funciton-dice}\n\n먼저 주사위를 모사하여 보자. 즉, 주사위를 물리적으로 만드는 대신 주사위를 던진 것과 동일한 효과가 나타나도록 이를 구현해 본다.\n\n1. 주사위 던지는 스크립트\n\n먼저 주사위 눈을 1,2,3,4,5,6 숫자 벡터로 정의하고 나서 `sample()` 함수로 `size=1`을 지정한다. 즉, 주사위 눈 6개중 임의로 하나를 선택한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndice <- c(1,2,3,4,5,6)\n\nsample(dice, size=1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n:::\n\n\n2. 함수 템플릿\n\n\"함수명 <- function() { }\"으로 구성되는 함수 템플릿을 작성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndraw_dice <- function() {\n  \n}\n```\n:::\n\n\n3. 함수 몸통으로 복사하여 붙여넣기 \n\n함수 몸통내부에 `dice <- c(1,2,3,4,5,6)`을 함수를 매번 호출할 때마다 실행시킬 필요는 없기 때문에 외부로 빼내고 실제 주사위 던지는 과정을 모사하는 코드만 복사하여 붙여넣는다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndice <- c(1, 2, 3, 4, 5, 6)\n\ndraw_dice <- function() {\n  sample(dice, size=1)\n}\n\ndraw_dice()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n4. 함수명, 함수 인자 등 마무리 \n\n함수명을 `draw_dice` 말고 다른 더 기억하기 좋고 짧고 간결한 형태로 필요한 경우 변경시키고, 인자도 없는 것에서 횟수를 지정할 수 있도록 변경시키고, 필요한 경우 `return` 함수를 지정하여 반환값을 명시적으로 적어 둔다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndraw_dice <- function(num_try) {\n  face <- sample(dice, size=num_try)\n  return(face) # 불필요함.\n}\n\ndraw_dice(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 4 2\n```\n\n\n:::\n:::\n\n\n\n\n## 왜 함수가 필요한가? {#why-write-function}\n\n왜 함수가 필요한지를 데이터를 분석할 때 자주 나오는 변수 정규화 사례를 바탕으로 살펴보자.\n\\footnote{해들리 위컴이 함수에 대해 필요성과 중요성을 언급하며 제시한 사례를 가져왔다. 자세한 사항은 R for Data Science 2판 26장 함수를 참고한다.}\n데이터프레임에 담긴 변수의 측도가 상이하여 변수를 상대적으로 비교하기 위해 \n측도를 재조정하여 표준화할 필요가 있다. \n변수에서 평균을 빼고 표준편차로 나누는 정규화도 있지만,\n최대값에서 최소값을 빼서 분모에 두고 분자에 최소값을 빼서 나누면 모든 변수가 \n0--1 사이 값으로 척도가 조정된다.\n\n$$ f(x)_{\\text{척도조정}} = \\frac{x-min(x)}{max(x)-min(x)} $$\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(a=c(1,2,3,4,5),\n        \t\t\t\t b=c(10,20,30,40,50),\n        \t\t\t\t c=c(7,8,6,1,3),\n        \t\t\t\t d=c(5,4,6,5,2))\ndf$a <- (df$a - min(df$a, na.rm = TRUE)) /\n        (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))\ndf$b <- (df$b - min(df$b, na.rm = TRUE)) /\n        (max(df$a, na.rm = TRUE) - min(df$b, na.rm = TRUE))\ndf$c <- (df$c - min(df$c, na.rm = TRUE)) /\n        (max(df$c, na.rm = TRUE) - min(df$c, na.rm = TRUE))\ndf$d <- (df$d - min(df$d, na.rm = TRUE)) /\n        (max(df$d, na.rm = TRUE) - min(df$d, na.rm = TRUE))\ndf        \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     a         b         c    d\n1 0.00  0.000000 0.8571429 0.75\n2 0.25 -1.111111 1.0000000 0.50\n3 0.50 -2.222222 0.7142857 1.00\n4 0.75 -3.333333 0.0000000 0.75\n5 1.00 -4.444444 0.2857143 0.00\n```\n\n\n:::\n:::\n\n\n상기 R 코드는 측도를 모두 맞춰서 변수 4개(`a`, `b`, `c`, `d`)를 비교하거나 향후 분석을 위한 것이다. \n하지만, 읽어야 하는 코드중복이 심하고 길어 코드를 작성한 개발자의 **의도** 가 본의 아니게 숨겨져 있다.\n작성한 R 코드에 실수한 것이 있는 경우, 다음 프로그램 실행에서 버그(특히, 구문론이 아닌 의미론적 버그)가 숨겨지게 된다. 상기 코드가 작성되는 과정을 살펴보면 본의 아니게 의도가 숨겨진다는 의미가 어떤 것인지 명확해진다.\n\n1. `df$a <- (df$a - min(df$a, na.rm = TRUE)) / (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))` 코드를 작성한 후,\n정상적으로 돌아가는지 확인한다.\n1. 1번 코드가 잘 동작하게 되면 다음 복사하여 붙여넣기 신공을 사용하여 다른 칼럼 작업을 확장해 나간다. `df$b`, `df$c`, `df$d`를 생성하게 된다.\n1. 즉, 복사해서 붙여넣은 것을 변수명을 편집해서 `df$b`, `df$c`, `df$d` 변수를 순차적으로 생성해 낸다.\n\n\n:::{.callout-note}\n### 해들리 위캠 어록\n\n* 중복은 의도를 숨기게 되고, 복사하여 붙여넣기 두번하면 함수를 작성할 시점이 되었다. (Duplication hides the intent. If you have copied-and-pasted twice, it is time to write a function.)\n\n:::\n\n## 함수 구성요소 {#funciton-component}\n\n### 인자(argument) {#function-component-argument}\n\n함수 구성요소 중 중요한 요소로 인자(argument)를 꼽을 수 있다. \n인자는 크게 두가지로 나뉜다.\n\n- 데이터 인자(data argumnets): 대다수 함수는 기본적으로 데이터에 대한 연산을 가정하고 있다. 따라서 데이터를 함수 인자로 지정하여 이를 함수몸통에서 처리하고 결과를 반환시키는 것은 당연한 귀결이다.\n- 동작방식 지정 인자(detail arguments): 함수가 동작하는 방식에 대해서 세부적으로 동작하는 방식에 대해서 지정할 필요가 있는데 이때 필요한 것이 동작방식 지정 인자가 된다.\n\n예를 들어 `t.test()` 함수를 살펴보면 `x`가 데이터 인자가 되며, 기타 `alternative = c(\"two.sided\", \"less\", \"greater\")`, `mu = 0`, `paired = FALSE`, `var.equal = FALSE`, `conf.level = 0.95`, `...`은 함수가 구체적으로 어떻게 동작하는지 명세한 인자값이다.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\n? t.test\n\n## Default S3 method:\nt.test(x, y = NULL,\n       alternative = c(\"two.sided\", \"less\", \"greater\"),\n       mu = 0, paired = FALSE, var.equal = FALSE,\n       conf.level = 0.95, ...)\n```\n:::\n\n\n### 인자값 확인 - `assert` {#function-component-argument-assert}\n\n인자값이 제대로 입력되어야 함수몸통에서 기술한 연산작업이 제대로 수행될 수 있다.\n이를 위해서 `testthat`, `assertive`, `assertr`, `assertthat` 등 수많은 팩키지가 존재한다.\n`stopifnot()`, `stop()` 등 Base R 함수를 사용해도 문제는 없다.\n\n다음과 같이 입력값에 `NA`가 포함된 경우 벡터의 합계를 구하는 함수가 동작하지 않거나 아무 의미없는 값을 반환시키곤 한다. 그리고 앞서 인자값을 잘 제어하지 않게 되면 귀중한 컴퓨팅 자원을 낭비하기도 한다. 이를 방기하기 위해서 `stopifnot()`함수로 함수 몸통을 수호하는 보호자처럼 앞서 인자값의 적절성에 대해서 검정을 먼저 수행한다. 그리고 나서 사전 유효성 검사를 통과한 인자값에 대해서만 함수 몸통에 기술된 연산작업을 수행하고 결과값을 반환시킨다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(testthat)\n\nnum_vector <- c(1,2,3,4, 5)\nna_vector <- c(1,2,3,NA, 5)\n\nsum_numbers <- function(vec) {\n  \n  stopifnot(!any(is.na(vec)))\n  \n  total <- 0\n\n  for(i in 1:length(vec)) {\n    total <- total + vec[i]\n  }\n  total\n}\n\nsum_numbers(num_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15\n```\n\n\n:::\n\n```{.r .cell-code}\nsum_numbers(na_vector)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in sum_numbers(na_vector): !any(is.na(vec)) is not TRUE\n```\n\n\n:::\n:::\n\n\n상기 코드의 문제점은 `stopifnot()` 함수가 잘못된 입력값에 대해서 문제가 무엇이고, 어떤 행동을 취해야 하는지 친절하지 않다는데 있다. 이를 [`assertive`](https://cran.r-project.org/web/packages/assertive/) 팩키지를 활용해서 극복하는 방안을 살펴보자. `asserive` 팩키지를 설치하면 R 함수 작성에 걸림돌이 될 수 있는 거의 모든 사전 점검작업을 수행할 수 있다는 것이 매력적이다. `install.packages(\"assertive\")`를 실행하게 되면 함께 설치되는 팩키지는 다음과 같다.\n\n‘assertive.base’, ‘assertive.properties’, ‘assertive.types’, ‘assertive.numbers’, ‘assertive.strings’, ‘assertive.datetimes’, ‘assertive.files’, ‘assertive.sets’, ‘assertive.matrices’, ‘assertive.models’, ‘assertive.data’, ‘assertive.data.uk’, ‘assertive.data.us’, ‘assertive.reflection’, ‘assertive.code’\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(assertive)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in library(assertive): 'assertive'이라고 불리는 패키지가 없습니다\n```\n\n\n:::\n\n```{.r .cell-code}\nsum_numbers_assertive <- function(vec) {\n  \n  assert_is_numeric(vec)\n  \n  if(assert_any_are_na(vec)) {\n      stop(\"벡터 x는 NA 값이 있어요. 그래서 총합을 구하는게 의미가 없네요\")\n  }\n  \n  total <- 0\n\n  for(i in 1:length(vec)) {\n    total <- total + vec[i]\n  }\n  total\n}\n\n# sum_numbers_assertive(num_vector)\nsum_numbers_assertive(na_vector)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in assert_is_numeric(vec): 함수 \"assert_is_numeric\"를 찾을 수 없습니다\n```\n\n\n:::\n:::\n\n\n\n### 반환값 확인 {#function-component-return}\n\nR은 파이썬과 달리 `return()`이 꼭 필요하지는 않다. 왜냐하면 마지막 객체가 자동으로 함수 반환값으로 정의되기 때문이다. 함수 반환값 관련하여 몇가지 사항을 알아두면 도움이 많이 된다.\n\n먼저 함수에서 반환되는 값이 하나가 아닌 경우 이를 담아내는 방법을 살펴보자. `list()`로 감싸 이를 반환하는 경우가 많이 사용되었지만, 최근 `zeallot` 팩키지가 도입되어 함수 출력값을 받아내는데 간결하고 깔끔하게 작업할 수 있게 되었다. [zeallot vignette](https://cran.r-project.org/web/packages/zeallot/vignettes/unpacking-assignment.html)에 다양한 사례가 나와 있다.\n\n예를 들어 단변량 회귀모형의 경우 `lm()` 함수로 회귀식을 적합시킨다. 그리고 나서 `coef()` 함수로 절편과 회귀계수를 추출할 때 `%<-%` 연산자를 사용하게 되면 해당값을 벡터객체에 할당시킬 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(zeallot)\n\nc(inter, slope) %<-% coef(lm(mpg ~ cyl, data = mtcars))\n\ncat(\"절편: \", inter, \"\\n기울기: \", slope)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n절편:  37.88458 \n기울기:  -2.87579\n```\n\n\n:::\n:::\n\n\n`iris` 데이터셋을 훈련/시험 데이터셋으로 쪼갠다. 이를 위해서 일양균등분포에서 난수를 생성시켜 8:2 비율로 훈련/시험 데이터를 나눈다.\n그리고 나서, `%<-%` 연산자로 훈련/시험 데이터로 나누어 할당하는 것도 가능하다.\n각 붓꽃마다 0~1 사이 난수를 생성하여 할당한다.\n그리고 난수값이 0.2  이상이면 훈련, 그렇지 않으면 시험 데이터로 구분한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris_df <- iris %>% \n  mutate(runif = runif(n())) %>% \n  mutate(train_test = ifelse(runif > 0.2, \"train\", \"test\")) \n\nc(test, train) %<-%  split(iris_df, iris_df$train_test)\n\ncat(\"총 관측점: \", nrow(iris), \"\\n훈련: \", nrow(train), \"\\n시험: \", nrow(test))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n총 관측점:  150 \n훈련:  126 \n시험:  24\n```\n\n\n:::\n:::\n\n\n혹은, 회귀분석 결과를 `list()` 함수로 결합시켜 리스트로 반환시킨다.\n이런 경우 결과값이 하나가 아니더라도 추후 리스트 객체를 풀어 활용하는 것이 가능하다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_lm_statistics <- function(df) {\n  mtcars_lm <- lm(mpg ~ cyl, data=df)\n  \n  intercept <- coef(mtcars_lm)[1]\n  beta      <- coef(mtcars_lm)[2]\n  \n  lm_stats <- list(intercept = intercept, \n                   beta = beta)\n  \n  return(lm_stats)\n}\n\nmtcars_list <- get_lm_statistics(mtcars)\n\nmtcars_list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$intercept\n(Intercept) \n   37.88458 \n\n$beta\n     cyl \n-2.87579 \n```\n\n\n:::\n:::\n\n\n\n## 함수를 작성하는 시점 {#time-to-write-function}\n\n복사해서 붙여넣는 것을 두번 하게 되면, 함수를 작성할 시점이다. \n중복을 제거하는 한 방법이 함수를 작성하는 것이고, 함수를 작성하게 되면 의도가 명확해진다.\n함수명을 `rescale`로 붙이고 이를 실행하게 되면, 의도가 명확하게 드러나게 되고, 복사해서 붙여넣게 되면서 \n생겨나는 중복과 반복에 의한 실수를 줄일 수 있게 되고, 향후 코드를 갱신할 때도 도움이 된다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrescale <- function(x){\n  rng <- range(x, na.rm = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n}\n\ndf$a <- rescale(df$a)\ndf$b <- rescale(df$b)\ndf$c <- rescale(df$c)\ndf$d <- rescale(df$d)\n```\n:::\n\n\n`rescale()` 함수를 사용해서 복사하여 붙여넣는 중복을 크게 줄였으나, 여전히 함수명을 반복해서 \n복사하여 붙여넣기를 통해 코드를 작성했다.\n함수형 프로그래밍을 사용하는 것으로 함수명을 반복적으로 사용하는 것조차도 피할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\ndf <- map_df(df, rescale)\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 4\n      a     b     c     d\n  <dbl> <dbl> <dbl> <dbl>\n1  0     1    0.857  0.75\n2  0.25  0.75 1      0.5 \n3  0.5   0.5  0.714  1   \n4  0.75  0.25 0      0.75\n5  1     0    0.286  0   \n```\n\n\n:::\n:::\n\n\n함수를 사용하지 않고 복사하여 붙여넣기 방식으로 코드를 작성한 경우 의도하지 않은 실수가 있어 \n함수를 도입하여 작성한 코드와 결과가 다른 것이 존재한다. \n코드를 읽어 찾아보거나 실행한 후 결과를 통해 버그를 찾아보는 것도 함수의 의미와 중요성을 파악하는데 도움이 된다.\n\n:::{.callout-note}\n### 좋은 함수란?\n\n척도를 일치시키는 기능을 함수로 구현했지만, 기능을 구현했다고 좋은 함수가 되지는 않는다.\n좋은 함수가 되는 조건은 다음과 같다.\n\n1. **Correct:** 기능이 잘 구현되어 올바르게 동작할 것\n1. **Understandable:** 사람이 이해할 수 있어야 함. 즉, 함수는 컴퓨터를 위해 기능이 올바르게 구현되고, 사람도 이해할 수 있도록 작성되어야 한다.\n1. 즉, **Correct + Understandable:** 컴퓨터와 사람을 위해 적성될 것.\n\n한걸음 더 들어가 구체적으로 좋은 함수는 다음과 같은 특성을 지니고 있다.\n\n1. 함수와 인자에 대해 유의미한 명칭을 사용한다.\n    * 함수명에 적절한 동사명을 사용한다.\n1. 직관적으로 인자를 배치하고 기본디폴트값에도 추론가능한 값을 사용한다.\n1. 함수가 인자로 받아 반환하는 것을 명확히 한다.\n1. 함수 내부 몸통부문에 일관된 스타일을 잘 사용한다.\n\n좋은 함수 작성과 연계하여  **깨끗한 코드(Clean code)**는 다음과 같은 특성을 갖고 작성된 코드를 뜻한다.\n\n- 가볍고 빠르다 - Light\n- 가독성이 좋다 - Readable\n- 해석가능하다 - Interpretable\n- 유지보수가 뛰어나다 - Maintainable\n\n:::\n\n\n## 사례: `rescale` 함수 {#how-to-write-function}\n\n함수를 작성할 경우 먼저 매우 단순한 문제에서 출발한다. \n척도를 맞추는 상기 과정을 R 함수로 만드는 과정을 통해 앞서 학습한 사례를 실습해 보자.\n\n1. 입력값과 출력값을 정의한다. 즉, 입력값이 `c(1,2,3,4,5)` 으로 들어오면 출력값은 \n`0.00 0.25 0.50 0.75 1.00` 0--1 사이 값으로 나오는 것이 확인되어야 하고, 각 원소값도\n출력벡터 원소값에 매칭이 되는지 확인한다.\n\n2. 기능이 구현되어 동작이 제대로 되는지 확인되는 R코드를 작성한다. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n(df$a - min(df$a, na.rm = TRUE)) / (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))\n```\n:::\n\n\n3. 확장가능하게 임시 변수를 사용해서 위에서 구현된 코드를 다시 작성한다. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n( x - min( x , na.rm = TRUE)) / (max( x , na.rm = TRUE) - min( x , na.rm = TRUE))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- df$a\n( x - min( x , na.rm = TRUE)) / (max( x , na.rm = TRUE) - min( x , na.rm = TRUE))\n```\n:::\n\n\n4. 함수 작성의도를 명확히 하도록 다시 코드를 작성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- df$a\nrng <- range(x, na.rm = TRUE)\n(x - rng[1]) / (rng[2] - rng[1])\n```\n:::\n\n\n5. 최종적으로 재작성한 코드를 함수로 변환한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- df$a\n\nrescale <- function(x){\n\t\t\t\trng <- range(x, na.rm = TRUE)\n\t\t\t\t(x - rng[1]) / (rng[2] - rng[1])\n\t\t\t}\n\nrescale(x)\n```\n:::\n\n\n## 사례: 요약통계 함수  {#function-is-argument}\n\n데이터를 분석할 때 가장 먼저 수행하는 작업이 요약통계를 통해 데이터를 이해하는 것이다. \n이미 훌륭한 요약통계 패키지와 함수가 있지만, 친숙한 개념을 함수로 다시 제작함으로써 함수에 대한 이해를 높일 수 있다.\n\n요약통계 기능을 먼저 구현한 다음에 중복 제거하여 요약통계 기능 함수를 제작해보자. 함수도 인자로 넣어 처리할 수 있다는 점이 처음에 이상할 수도 있지만, 함수를 인자로 처리할 경우 코드 중복을 상당히 줄일 수 있다.\n$L_1$, $L_2$, $L_3$ 값을 구하는 함수를 다음과 같이 작성하는 경우, 숫자 1,2,3 만 차이날 뿐 다른 부분은 동일하기 때문에 함수 코드에 중복이 심하게 관찰된다.\n\n* 1단계: 중복이 심한 함수, 기능 구현에 초점을 맞춤\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf1 <- function(x) abs(x - mean(x)) ^ 1\nf2 <- function(x) abs(x - mean(x)) ^ 2\nf3 <- function(x) abs(x - mean(x)) ^ 3\n```\n:::\n\n\n* 2단계: 임시 변수로 처리할 수 있는 부분을 식별하고 적절한 인자명(`power`)을 부여한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf1 <- function(x) abs(x - mean(x)) ^ power\nf2 <- function(x) abs(x - mean(x)) ^ power\nf3 <- function(x) abs(x - mean(x)) ^ power\n```\n:::\n\n\n* 3단계: 식별된 변수명을 함수 인자로 변환한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf1 <- function(x, power) abs(x - mean(x)) ^ power\nf2 <- function(x, power) abs(x - mean(x)) ^ power\nf3 <- function(x, power) abs(x - mean(x)) ^ power\n```\n:::\n\n\n여기서 요약통계함수 인자로 \"데이터\"(`df`)와 기초통계 요약 \"함수\"(`mean`, `sd` 등)도 함께 넘겨 요약통계함수를 간략하고 가독성 높게 작성할 수 있다.\n\n먼저, 특정 변수의 중위수, 평균, 표준편차를 계산하는 함수를 작성하는 경우를 가정해보자.\n\n* 1 단계: 각 기능을 구현하는 기능 구현에 초점을 맞춤\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncol_median <- function(df) {\n    output <- numeric(length(df))\n    for (i in seq_along(df)) {\n      output[i] <- median(df[[i]])\n    }\n    output\n  }\n\ncol_mean <- function(df) {\n    output <- numeric(length(df))\n    for (i in seq_along(df)) {\n      output[i] <- mean(df[[i]])\n    }\n    output\n  }\n\ncol_sd <- function(df) {\n    output <- numeric(length(df))\n    for (i in seq_along(df)) {\n      output[i] <- sd(df[[i]])\n    }\n    output\n  }\n```\n:::\n\n\n* 2 단계: `median`, `mean`, `sd`를 함수 인자 `fun` 으로 함수명을 통일.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncol_median <- function(df) {\n    output <- numeric(length(df))\n    for (i in seq_along(df)) {\n      output[i] <- fun(df[[i]])\n    }\n    output\n  }\n\ncol_mean <- function(df) {\n    output <- numeric(length(df))\n    for (i in seq_along(df)) {\n      output[i] <- fun(df[[i]])\n    }\n    output\n  }\n\ncol_sd <- function(df) {\n    output <- numeric(length(df))\n    for (i in seq_along(df)) {\n      output[i] <- fun(df[[i]])\n    }\n    output\n  }\n```\n:::\n\n\n* 3 단계: 함수 인자 `fun` 을 넣어 중복을 제거.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncol_median <- function(df, fun) {\n    output <- numeric(length(df))\n    for (i in seq_along(df)) {\n      output[i] <- fun(df[[i]])\n    }\n    output\n  }\n\ncol_mean <- function(df, fun) {\n    output <- numeric(length(df))\n    for (i in seq_along(df)) {\n      output[i] <- fun(df[[i]])\n    }\n    output\n  }\n\ncol_sd <- function(df, fun) {\n    output <- numeric(length(df))\n    for (i in seq_along(df)) {\n      output[i] <- fun(df[[i]])\n    }\n    output\n  }\n```\n:::\n\n\n* 4 단계: 함수를 인자로 갖는 요약통계 함수를 최종적으로 정리하고, 테스트 사례를 통해 검증.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncol_summary <- function(df, fun) {\n    output <- numeric(length(df))\n    for (i in seq_along(df)) {\n      output[i] <- fun(df[[i]])\n    }\n    output\n}\n\ncol_summary(df, fun = median)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5000000 0.5000000 0.7142857 0.7500000\n```\n\n\n:::\n\n```{.r .cell-code}\ncol_summary(df, fun = mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5000000 0.5000000 0.5714286 0.6000000\n```\n\n\n:::\n\n```{.r .cell-code}\ncol_summary(df, fun = sd)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.3952847 0.3952847 0.4164966 0.3791438\n```\n\n\n:::\n:::\n",
    "supporting": [
      "functions_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}