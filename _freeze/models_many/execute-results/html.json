{
  "hash": "483cef62a9a670c4cbfe12392326d90e",
  "result": {
    "markdown": "---\neditor_options: \n  chunk_output_type: console\neditor: \n  markdown: \n    wrap: 72\n---\n\n\n# 많은 회귀모형 {#purrr-many-models}\n\n## 기대수명 데이터 {#model-reg-viz-data}\n\n`gapminder` 데이터를 가지고 회귀모형을 구축하고 모형을 활용하여 종속변수(기대수명, `lifeExp`)가 늘어나지 못한 국가를 뽑아내고 이를 시각적으로 확인해보자.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 0. 환경설정 -----\n# 데이터\nlibrary(gapminder)\n\n# Tidyverse\nlibrary(tidyverse)\n\n# 모형\nlibrary(broom)\n\n# 1. 데이터 -----\ngapminder\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n### 기대수명 회귀분석 {#model-reg-viz-model}\n\n대륙과 국가를 그룹으로 잡아 회귀분석을 각각에 대해서 돌리고 나서,\n모형 결과값을 데이터와 모형이 함께 위치하도록 티블(tibble)에 저장시켜 놓은다.\n그리고 나서, 주요한 회귀모형 성능지표인 결정계수($R^2$)를 기준으로 정렬시킨다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 2. 모형 -----\ncountry_model <- function(df)\n  lm(lifeExp ~ year, data=df)\n\nby_country <- gapminder %>% \n  group_by(country, continent) %>% \n  nest() %>% \n  mutate(model = map(data, country_model),\n         model_glance = map(model, glance),\n         rsquare = map_dbl(model_glance, ~.$r.squared)) |> \n  ungroup()\n\nby_country %>% \n  arrange(rsquare)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 142 × 6\n   country          continent data              model  model_glance      rsquare\n   <fct>            <fct>     <list>            <list> <list>              <dbl>\n 1 Rwanda           Africa    <tibble [12 × 4]> <lm>   <tibble [1 × 12]>  0.0172\n 2 Botswana         Africa    <tibble [12 × 4]> <lm>   <tibble [1 × 12]>  0.0340\n 3 Zimbabwe         Africa    <tibble [12 × 4]> <lm>   <tibble [1 × 12]>  0.0562\n 4 Zambia           Africa    <tibble [12 × 4]> <lm>   <tibble [1 × 12]>  0.0598\n 5 Swaziland        Africa    <tibble [12 × 4]> <lm>   <tibble [1 × 12]>  0.0682\n 6 Lesotho          Africa    <tibble [12 × 4]> <lm>   <tibble [1 × 12]>  0.0849\n 7 Cote d'Ivoire    Africa    <tibble [12 × 4]> <lm>   <tibble [1 × 12]>  0.283 \n 8 South Africa     Africa    <tibble [12 × 4]> <lm>   <tibble [1 × 12]>  0.312 \n 9 Uganda           Africa    <tibble [12 × 4]> <lm>   <tibble [1 × 12]>  0.342 \n10 Congo, Dem. Rep. Africa    <tibble [12 × 4]> <lm>   <tibble [1 × 12]>  0.348 \n# ℹ 132 more rows\n```\n\n\n:::\n:::\n\n\n\n### 회귀모형 시각화 {#model-reg-viz-model-trelliscope}\n\n데이터셋 `by_country`를 이용하여 각 나라별로 회귀 모델의 $ R^2 $ (결정 계수) 값을 기반으로 \"적합국\"과 \"비적합국\"을 분류하고, 그 결과를 시각화한다. $ R^2 $ 값이 큰 나라 5개와 작은 나라 5개를 추출하여 기대수명 변화를 그래프로 대조하여 국가별 차이를 명확히 한다.\n\n\n1. **최대 $ R^2 $ 값의 국가 추출**:\n   - `by_country` 데이터셋에서 `rsquare` 값이 가장 큰 5개의 국가를 추출한다.\n   - 해당 국가 이름들을 `rsquare_max_countries`에 저장한다.\n\n2. **최소 $ R^2 $ 값의 국가 추출**:\n   - `by_country` 데이터셋에서 `rsquare` 값이 가장 작은 5개의 국가를 추출한다.\n   - 해당 국가 이름들을 `rsquare_min_countries`에 저장한다.\n\n3. **데이터 필터링 및 시각화**:\n   - 총 10개 국가에 해당하는 데이터만 `by_country`에서 추출한다.\n   - 추출된 데이터에서 나라명, 대륙명, $ R^2 $ 값, 그리고 원데이터를 추출한다.\n   - 결과를 $ R^2 $ 값의 내림차순으로 정렬한다.\n   - 데이터를 정리하여 각 나라의 연도별 기대수명을 나타내는 선그래프를 생성하고, 그래프에서는 $ R^2 $ 값이 높은 국가들을 \"발전된국가\"로, 낮은 값을 가진 국가들을 \"개발국\"으로 분류하여 색상을 달리하여 시각화할 재료로 준비한다.\n\n최종적으로는 각 국가별로 연도에 따른 기대수명 변화를 보여주는 그래프를 생성한다. $ R^2 $ 값이 높은 국가들은 빨간색으로, 낮은 국가들은 파란색으로 표시한고, 마지막으로 회귀모형이 얼마나 잘 적합되었는지에 따라 각 국가의 기대수명 변화 패턴을 비교한다. 파란색으로 회귀모형이 잘 적합된 경우에도 서로 다른 패턴이 확인된다. 즉, 선진국과 개발도상국 모두 제2차 세계대전 이후 기대수명이 증대했으나 선진국은 높은 기대수명에서 개도국은 낮은 기대수명에서 시작해서 모두 기대수명이 높아진 것이 눈에 띈다. 하지만, 빨간색으로 회귀계수가 낮은 나라는 기대수명이 높아지다가 특정 사건으로 인해 기대수명이 제자리로 돌아온 이후 다시 기대수명이 높아지는 추세를 보여 비선형적 관계를 보여주고 있어 회귀계수가 전반적으로 낮게 나타났다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrsquare_max_countries <- by_country |> \n  slice_max(order_by = rsquare, n = 5)  |> \n  pull(country) |> \n  droplevels()\n\nrsquare_min_countries <- by_country |> \n  slice_min(order_by = rsquare, n = 5) |> \n  pull(country) |> \n  droplevels()\n\nby_country |> \n  filter(country %in% rsquare_max_countries | country %in% rsquare_min_countries) |> \n  select(country, continent, rsquare, data) |> \n  arrange(desc(rsquare)) |> \n  unnest(data) |> \n  mutate(country = factor(country, levels = c(rsquare_max_countries, rsquare_min_countries))) |> \n  mutate(class = if_else(country %in% rsquare_max_countries, \"발전된국가\", \"개발국\")) |> \n  ggplot(aes(x = year, y = lifeExp, color = class)) +\n    geom_line() +\n    facet_wrap(~country, nrow = 2) +\n    scale_color_manual(values = c(\"red\", \"blue\")) +\n    theme_minimal() +\n    theme(legend.position = \"none\",\n          axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +\n    labs(title =\"회귀모형 기대수명 적합국과 비적합국\",\n         x = \"\",\n         y = \"기대수명\",\n         caption = \"자료출처: gapminder\")\n```\n\n::: {.cell-output-display}\n![](models_many_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n## 모형식별\n\n`purrr` 팩키지를 활용하여 원본 모형 데이터와 모형을 하나의 데이터프레임(`tibble`)에 담을 수가 있다.\n즉, 6가지 서로 다른 회귀모형을 일괄적으로 적합시키고 가장 AIC 값이 적은 회귀모형을 선택하는 코드를 다음과 같이 작성한다. [^many-models]\n\n[^many-models]: [DAN OVANDO(FEBRUARY 20, 2018), \"DATA WRANGLING AND MODEL FITTING USING PURRR\"](https://www.weirdfishes.blog/blog/practical-purrr/)\n\n1. `reg_models`: 다양한 회귀모형을 정의한다.\n1. `mutate(map())`: 정의한 회귀모형 각각을 적합시키고 모형성능 지표를 추출한다.\n1. AIC 기준으로 가장 낮은 모형을 선정한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(gapminder)\n\n## 데이터셋 준비 -----\ngapminder <- gapminder %>%\n  set_names(colnames(.) %>% tolower())\n\n## 다양한 회귀모형 -----\nreg_models <- list(\n  `01_pop` = 'lifeexp ~ pop',\n  `02_gdppercap` = 'lifeexp ~ gdppercap',\n  `03_simple` = 'lifeexp ~ pop + gdppercap',\n  `04_medium` = 'lifeexp ~ pop + gdppercap + continent + year',\n  `05_more`   = 'lifeexp ~ pop + gdppercap + country + year',\n  `06_full`   = 'lifeexp ~ pop + gdppercap + year*country')\n\nmodel_tbl <- tibble(reg_formula = reg_models) %>%\n  mutate(model_name = names(reg_formula)) %>% \n  select(model_name, reg_formula) %>% \n  mutate(reg_formula = map(reg_formula, as.formula))\n\nmodel_tbl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 2\n  model_name   reg_formula \n  <chr>        <named list>\n1 01_pop       <formula>   \n2 02_gdppercap <formula>   \n3 03_simple    <formula>   \n4 04_medium    <formula>   \n5 05_more      <formula>   \n6 06_full      <formula>   \n```\n\n\n:::\n\n```{.r .cell-code}\n## 회귀모형 적합 및 모형 성능 지표 -----\nmodel_tbl <- model_tbl %>%\n  mutate(fit = map(reg_formula, ~lm(., data = gapminder))) %>% \n  mutate(model_glance = map(fit, broom::glance),\n         rsquare      = map_dbl(model_glance, ~.$r.squared),\n         AIC          = map_dbl(model_glance, ~.$AIC)) %>% \n  arrange(AIC)\n\nmodel_tbl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 6\n  model_name   reg_formula  fit          model_glance      rsquare    AIC\n  <chr>        <named list> <named list> <named list>        <dbl>  <dbl>\n1 06_full      <formula>    <lm>         <tibble [1 × 12]> 0.976    7752.\n2 05_more      <formula>    <lm>         <tibble [1 × 12]> 0.932    9268.\n3 04_medium    <formula>    <lm>         <tibble [1 × 12]> 0.717   11420.\n4 03_simple    <formula>    <lm>         <tibble [1 × 12]> 0.347   12836.\n5 02_gdppercap <formula>    <lm>         <tibble [1 × 12]> 0.341   12850.\n6 01_pop       <formula>    <lm>         <tibble [1 × 12]> 0.00422 13553.\n```\n\n\n:::\n:::\n\n\n### 교차검증 `CV` {#cv-reg-model}\n\n데이터를 10조각내서 교차검정을 통해 RMSE가 가장 작은 회귀모형이 어떤 것인지 살펴보자.\n`cross_df()` 함수로 교차검증 `splits` 데이터와 모형을 준비한다.\n다음으로 `analysis()` 함수로 교차검증 데이터에 대해서 회귀모형 각각을 적합시키고,\n`assessment()` 함수로 적합시킨 모형에 대해 모형성능을 살펴본다.\n마지막으로 RMSE 회귀모형 성능지표를 통해 모형선택을 한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## 교차검정 -----\nvalid_tbl <- gapminder %>%\n  rsample::vfold_cv(10)\n\ncv_tbl <- list(test_training = list(valid_tbl), \n               model_name = model_tbl$model_name)  \n  \ncv_tbl <- tidyr::expand_grid(test_training = list(valid_tbl), \n                             model_name = model_tbl$model_name)\n\ncv_tbl <- cv_tbl %>%\n  mutate(model_number = row_number()) %>%  # Manually creating the model_number column\n  left_join(model_tbl %>% select(model_name, reg_formula), by = \"model_name\") %>% \n  unnest(cols = c(test_training))\n\ncv_tbl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 5\n   splits             id     model_name model_number reg_formula \n   <list>             <chr>  <chr>             <int> <named list>\n 1 <split [1533/171]> Fold01 06_full               1 <formula>   \n 2 <split [1533/171]> Fold02 06_full               1 <formula>   \n 3 <split [1533/171]> Fold03 06_full               1 <formula>   \n 4 <split [1533/171]> Fold04 06_full               1 <formula>   \n 5 <split [1534/170]> Fold05 06_full               1 <formula>   \n 6 <split [1534/170]> Fold06 06_full               1 <formula>   \n 7 <split [1534/170]> Fold07 06_full               1 <formula>   \n 8 <split [1534/170]> Fold08 06_full               1 <formula>   \n 9 <split [1534/170]> Fold09 06_full               1 <formula>   \n10 <split [1534/170]> Fold10 06_full               1 <formula>   \n# ℹ 50 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n## 교차검정 analysis, assessment -----\ncv_fit_tbl <- cv_tbl %>%\n  mutate(fit = map2(reg_formula, splits, ~lm(.x, data = rsample::analysis(.y)))) %>%\n  mutate(RMSE = map2_dbl(fit, splits, ~modelr::rmse(.x, rsample::assessment(.y))))\n\ncv_fit_tbl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 7\n   splits             id     model_name model_number reg_formula  fit       RMSE\n   <list>             <chr>  <chr>             <int> <named list> <named > <dbl>\n 1 <split [1533/171]> Fold01 06_full               1 <formula>    <lm>      2.18\n 2 <split [1533/171]> Fold02 06_full               1 <formula>    <lm>      2.13\n 3 <split [1533/171]> Fold03 06_full               1 <formula>    <lm>      3.07\n 4 <split [1533/171]> Fold04 06_full               1 <formula>    <lm>      2.88\n 5 <split [1534/170]> Fold05 06_full               1 <formula>    <lm>      2.33\n 6 <split [1534/170]> Fold06 06_full               1 <formula>    <lm>      2.57\n 7 <split [1534/170]> Fold07 06_full               1 <formula>    <lm>      2.35\n 8 <split [1534/170]> Fold08 06_full               1 <formula>    <lm>      2.57\n 9 <split [1534/170]> Fold09 06_full               1 <formula>    <lm>      2.26\n10 <split [1534/170]> Fold10 06_full               1 <formula>    <lm>      2.45\n# ℹ 50 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n## 시각화 -----\ncv_fit_tbl %>%\n  ggplot(aes(RMSE, fill = model_name)) +\n  geom_density(alpha = 0.75) +\n  labs(x = \"RMSE\", title = \"gapminder 회귀모형별 교차검정 분포\")\n```\n\n::: {.cell-output-display}\n![](models_many_files/figure-html/gapminder-cv-reg-1.png){width=672}\n:::\n:::\n\n\n\n### 병렬처리 - `furrr` {#cv-reg-model-furrr}\n\n`parallel::detectCores()`을 통해 전체 코어 숫자를 확인하고 이를 병렬처리를 통해 교차검증에 따른 시간을 대폭 절감시킨다. 이를 위해서 `future` 팩키지를 사용하고 절약되는 시간을 측정하기 위해서 `tictoc` 팩키지를 동원한다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(furrr)\nlibrary(tictoc)\n\nplan(multisession, workers = parallel::detectCores() - 1)\n```\n:::\n\n\n\n::::: {.columns}\n::: {.column}\n\n**`purrr` 순차처리**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## purrr 순차처리 -----\ntic()\n\ncv_fit_tbl <- cv_tbl %>%\n  mutate(fit = map2(reg_formula, splits, ~lm(.x, data = rsample::analysis(.y))))\n\ntoc()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1.14 sec elapsed\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.column}\n**`furrr` 병렬처리**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## furrr 병렬처리 ----\ntic()\n\ncv_fit_tbl <- cv_tbl %>%\n  mutate(fit = future_map2(reg_formula, splits, ~lm(.x, data = rsample::analysis(.y)), .progress=TRUE)) \n\ntoc()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n18.17 sec elapsed\n```\n\n\n:::\n:::\n\n\n:::\n:::::\n\n\n\n",
    "supporting": [
      "models_many_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}