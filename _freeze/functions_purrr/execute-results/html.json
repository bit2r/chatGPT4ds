{
  "hash": "b0ca2ee23c58e3571cd84d0d16e12c07",
  "result": {
    "engine": "knitr",
    "markdown": "---\noutput: html_document\neditor_options: \n  chunk_output_type: console\neditor: \n  markdown: \n    wrap: 72\n---\n\n\n# 함수형 프로그래밍 {#r-functional-programming}\n\n데이터 과학 맥락에서 함수형 프로그래밍을 이해하고, 수치해석 예제를 통해\n코드를 작성하고, 함수형 프로그래밍과 짝꿍인 단위 테스트에 대해서\n살펴본다.\n\n**함수형 프로그래밍(functional programming)**은 코드를 작성하는 한\n방식으로 특정 연산을 수행하는 함수를 먼저 작성하고 나서, 사용자가 함수를\n호출해서 작업을 수행하는 방식이다. 순수 함수형 언어, 예를 들어\n[하스켈(Haskell)](https://ko.wikipedia.org/wiki/하스켈)은 루프가 없다.\n루푸없이 어떻게 프로그램을 작성할 수 있을까? 루프는 재귀(recursion)로\n대체된다. 이런 이유로 아래에서 뉴톤 방법을 통해 근을 구하는 방식을\nR코드로 두가지 방법을 보여준다. R은 아직 [꼬리 호출(tail-call\nrecurssion)](http://hanmomhanda.github.io/2015/07/27/%EC%9E%AC%EA%B7%80-%EB%B0%98%EB%B3%B5-Tail-Recursion/)\n기능을 제공하지 않기 때문에 루프를 사용하는 것이 더 낫다.\n\n수학 함수는 멋진 특성이 있는데, 즉 해당 입력에 항상 동일한 결과를\n갖는다. 이 특성을 **참조 투명성(referential transparaency)** 이라고\n부른다. 참조 투명성은 **부수효과(side effect)** 없음을 표현하는\n속성인데, 함수가 결과값 외에 다른 상태를 변경시킬 때 부수효과(side\neffect)가 있다고 한다. 부수 효과는 프로그램 버그를 발생시키는 온상으로,\n부수 효과를 없애면 디버깅이 용이해진다. 따라서, 부수 효과를 제거하고\n참조 투명성을 유지함으로써 데이터 분석 수행 결과를 예측 가능한 상태로\n유지시켜 **재현가능한 과학**이 가능하게 된다.\n\n::: callout-note\n### 함수형 프로그래밍\n\nR 함수형 프로그래밍을 이해하기 위해서는 먼저 자료구조에 대한 이해가\n선행되어야 한다. 그리고 나서, 함수를 작성하는 이유와 더불어 작성법에\n대한 이해도 확고히 해야만 한다.\n\n객체(object)가 함수를 갖는 데이터라면, 클러져는 데이터를 갖는 함수다.\n\n> \"An object is data with functions. A closure is a function with data.\"\n> -- John D. Cook\n:::\n\n명령형 언어(Imperative Language) 방식으로 R코드를 쭉 작성하게 되면, 각\n단계별로 상태가 변경되는 것에 대해 신경을 쓰고 관리를 해나가야 된다.\n그렇지 않으면 예기치 않은 부수 효과가 발생하여 데이터 분석 및 모형을\n잘못 해석하게 된다.\n\n그렇다고, 부수효과가 없는 순수 함수가 반듯이 좋은 것은 아니다. 예를 들어\n`rnorm()` 함수를 통해 평균 0, 분산 1인 난수를 생성시키는데, 항상 동일한\n값만 뽑아내면 사용자에게 의미있는 함수는 아니다.\n\n결국, 함수형 프로그래밍을 통해 **테스팅(testing)**과\n**디버깅(debugging)**을 수월하게 하는 것이 추구하는 바이다. 이를 위해\n다음 3가지 요인이 중요하다.\n\n-   한번에 한가지 작업을 수행하는 함수\n-   부수효과(side effect) 회피\n-   참조 투명성(Referential transparaency)\n\n## 왜 함수형 프로그래밍인가? {#why-functional-programming}\n\n데이터 분석을 아주 추상화해서 간략하게 얘기한다면 데이터프레임을 함수에\n넣어 새로운 데이터프레임으로 만들어 내는 것이다.\n\n![함수로 이해하는 데이터\n분석](images/fp-data-analysis.png){fig-align=\"center\" width=\"810\"}\n\n데이터 분석, 데이터 전처리, 변수 선택, 모형 개발이 한번에 해결되는 것이\n아니라서, 데이터프레임을 함수에 넣어 상태가 변경된 데이터프레임이\n생성되고, 이를 다시 함수에 넣어 또다른 변경된 상태 데이터프레임을 얻게\n되는 과정을 쭉 반복해 나간다.\n\n![데이터 분석\n작업흐름](images/fp-data-analysis-workflow.png){fig-align=\"center\"\nwidth=\"377\"}\n\n따라서... 데이터 분석에는 함수형 프로그래밍 패러다임을 활용하고,\n툴/패키지 개발에는 객체지향 프로그래밍 패러다임 사용이 권장된다.\n\n![데이터 분석과 툴/패키지 도구\n개발](images/fp-data-analysis-choice.png){fig-align=\"center\"\nwidth=\"687\"}\n\n## [뉴튼 방법(Newton's Method)](https://en.wikipedia.org/wiki/Newton%27s_method) {#functional-programming-newton}\n\n뉴튼-랩슨 알고리즘으로도 알려진 뉴튼(Newton Method) 방법은 컴퓨터를\n사용해서 수치해석 방법으로 실함수의 근을 찾아내는 방법이다.\n\n특정 함수 $f$ 의 근을 찾을 경우, 함수 미분값 $f'$, 초기값 $x_0$가\n주어지면 근사적 근에 가까운 값은 다음과 같이 정의된다.\n\n$$x_{1} = x_0 - \\frac{f(x_0)}{f'(x_0)}$$\n\n이 과정을 반복하게 되면 오차가 매우 적게 근의 값에 도달하게 된다.\n\n$$x_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)}$$\n\n기하적으로 보면, 파란 선은 함수 $f$ 이고, $f$를 미분한 $f'$ 빨간 선은\n뉴턴방법을 활용하여 근을 구해가는 과정을 시각적으로 보여주고 있다.\n$x_{n-1}$ 보다 $x_n$이, $x_n$ 보다 $x_{n+1}$이 함수 $f$ 근에 더 가깝게\n접근해 나가는 것이 확인된다.\n\n![뉴튼 방법 도식화](images/newton_method_ani.gif)\n\n## 뉴튼 방법 R 코드 [^functions_purrr-1] {#functional-programming-newton-method}\n\n[^functions_purrr-1]: [Bruno Rodrigues(2016), \"Functional programming\n    and unit testing for data munging with R\", LeanPub,\n    2016-12-23](http://www.brodrigues.co/fput/)\n\n뉴튼 방법을 R코들 구현하면 다음과 같이 612의 제곱근 값을 수치적으로\n컴퓨터를 활용하여 구할 수 있다. `while`같은 루프를 활용하여 반복적으로\n해를 구하는 것도 가능하지만 재귀를 활용하여 해를 구하는 방법이 코드를\n작성하고 읽는 개발자 관점에서는 훨씬 더 편리하고 권장된다.\n\n하지만, 속도는 `while` 루프를 사용하는 것이 R에서는 득이 많다. 이유는\n오랜 세월에 걸쳐 최적화 과정을 거쳐 진화했기 때문이다.\n\n::: row\n::: col-md-6\n**while 루프를 사용한 방법**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfind_root <- function(guess, init, eps = 10^(-10)){\n    while(abs(init**2 - guess) > eps){\n        init <- 1/2 *(init + guess/init)\n        cat(\"현재 값: \", init, \"\\n\")\n    }\n    return(init)\n}\n\nfind_root(612, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n현재 값:  35.6 \n현재 값:  26.39551 \n현재 값:  24.79064 \n현재 값:  24.73869 \n현재 값:  24.73863 \n현재 값:  24.73863 \n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 24.73863\n```\n\n\n:::\n:::\n\n:::\n\n::: col-md-6\n**재귀를 사용한 방법**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfind_root_recur <- function(guess, init, eps = 10^(-10)){\n    if(abs(init**2 - guess) < eps){\n        return(init)\n    } else{\n        init <- 1/2 *(init + guess/init)\n        cat(\"재귀방법 현재 값: \", init, \"\\n\")\n        return(find_root_recur(guess, init, eps))\n    }\n}\n\nfind_root_recur(612, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n재귀방법 현재 값:  35.6 \n재귀방법 현재 값:  26.39551 \n재귀방법 현재 값:  24.79064 \n재귀방법 현재 값:  24.73869 \n재귀방법 현재 값:  24.73863 \n재귀방법 현재 값:  24.73863 \n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 24.73863\n```\n\n\n:::\n:::\n\n:::\n:::\n\n## `Map()`, `Reduce()`와 `*apply()` 함수 {#map-reduce-apply}\n\n함수를 인자로 받는 함수를 고차함수(High-order function)라고 부른다.\n대표적으로 `Map()`, `Reduce()`가 있다. 숫자 하나가 아닌 벡터에 대한\n제곱근을 구하기 위해서 `Map` 함수를 사용한다. [^functions_purrr-2]\n[^functions_purrr-3]\n\n[^functions_purrr-2]: [`purrr` tutorial: Lessons and\n    Examples](https://jennybc.github.io/purrr-tutorial/index.html)\n\n[^functions_purrr-3]: [`purrr` tutorial GitHub\n    Webpage](https://github.com/jennybc/purrr-tutorial/)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 제곱근 함수 -------------------------------------------\n\nfind_root_recur <- function(guess, init, eps = 10^(-10)){\n    if(abs(init**2 - guess) < eps){\n        return(init)\n    } else{\n        init <- 1/2 *(init + guess/init)\n        return(find_root_recur(guess, init, eps))\n    }\n}\n\n# 벡터에 대한 제곱근 계산 \n\nnumbers <- c(16, 25, 36, 49, 64, 81)\nMap(find_root_recur, numbers, init=1, eps = 10^-10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 4\n\n[[2]]\n[1] 5\n\n[[3]]\n[1] 6\n\n[[4]]\n[1] 7\n\n[[5]]\n[1] 8\n\n[[6]]\n[1] 9\n```\n\n\n:::\n:::\n\n\n숫자 하나를 받는 함수가 아니라, 벡터를 인자로 받아 제곱근을 계산하는\n함수를 작성할 경우 함수 내부에서 함수를 인자로 받을 수 있도록 `Map`\n함수를 활용한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# `Map` 벡터 제곱근 계산\n\nfind_vec_root_recur <- function(numbers, init, eps = 10^(-10)){\n    return(Map(find_root_recur, numbers, init, eps))\n}\n\nnumbers_z <- c(9, 16, 25, 49, 121)\nfind_vec_root_recur(numbers_z, init=1, eps=10^(-10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 3\n\n[[2]]\n[1] 4\n\n[[3]]\n[1] 5\n\n[[4]]\n[1] 7\n\n[[5]]\n[1] 11\n```\n\n\n:::\n:::\n\n\n이러한 패턴이 많이 활용되어 `*apply` 함수가 있어, 이전에 많이 사용했을\n것이다. 벡터를 인자로 먼저 넣고, 함수명을 두번째 인자로 넣고, 함수에\n들어갈 매개변수를 순서대로 쭉 나열하여 `lapply`, `sapply` 함수에 넣는다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# `lapply` 활용 제급근 계산\n\nlapply(numbers_z, find_root_recur, init=1, eps=10^(-10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 3\n\n[[2]]\n[1] 4\n\n[[3]]\n[1] 5\n\n[[4]]\n[1] 7\n\n[[5]]\n[1] 11\n```\n\n\n:::\n\n```{.r .cell-code}\nsapply(numbers_z, find_root_recur, init=1, eps=10^(-10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  3  4  5  7 11\n```\n\n\n:::\n:::\n\n\n`Reduce` 함수도 삶을 편안하게 할 수 있는, 루프를 회피하는 또다른\n방법이다. 이름에서 알 수 있듯이 `numbers_z` 벡터 원소 각각에 대해 해당\n연산작업 `+`, `%%`을 수행시킨다. `%%`는 나머지 연산자로 기본디폴트\n설정으로 $\\frac{10}{7}$로 몫 대신에 나머지 3을 우선 계산하고, 그\n다음으로 $\\frac{3}{5}$로 최종 나머지 3을 순차적으로 계산하여 결과를\n도출한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Reduce ----------------------------------------------\nnumbers_z\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]   9  16  25  49 121\n```\n\n\n:::\n\n```{.r .cell-code}\nReduce(`+`, numbers_z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 220\n```\n\n\n:::\n\n```{.r .cell-code}\nnumbers_z <- c(10,7,5)\nReduce(`%%`, numbers_z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n## `purrr` 팩키지 {#functional-programming-purrr}\n\n`*apply` 계열 함수는 각각의 자료형에 맞춰 기억하기가 쉽지 않아, 매번\n도움말을 찾아 확인하고 코딩을 해야하는 번거러움이 많다. 데이터 분석을\n함수형 프로그래밍 패러다임으로 실행하도록 `purrr` 팩키지가 개발되었다.\n이를 통해 데이터 분석 작업이 수월하게 되어 저녁이 있는 삶이 길어질\n것으로 기대된다.\n\n### `purrr` 헬로월드 {#functional-programming-purrr-hello-world}\n\n`purrr` 팩키지를 불러와서 `map_dbl()` 함수에 구문에 맞게 작성하면 동일한\n결과를 깔끔하게 얻을 수 있다. 즉,\n\n-   `map_dbl()`: 벡터, 데이터프레임, 리스트에 대해 함수를 원소별로\n    적용시켜 결과를 `double` 숫자형으로 출력시킨다.\n-   `numbers`: 함수를 각 원소별로 적용시킬 벡터 입력값\n-   `find_root_recur`: 앞서 작성한 뉴톤 방법으로 제곱근을 수치적으로\n    구하는 사용자 정의함수.\n-   `init=1, eps = 10^-10`: 뉴톤 방법을 구현한 사용자 정의함수에 필요한\n    초기값.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\nnumbers <- c(16, 25, 36, 49, 64, 81)\nmap_dbl(numbers, find_root_recur, init=1, eps = 10^-10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 5 6 7 8 9\n```\n\n\n:::\n:::\n\n\n## 병렬 데이터 분석 {#functional-programming-purrr-read-iris}\n\n구글 검색을 통해서 쉽게 [iris(붓꽃)\n데이터](https://gist.githubusercontent.com/curran/a08a1080b88344b0c8a7/raw/d546eaee765268bf2f487608c537c05e22e4b221/iris.csv)를\n구할 수 있다. 이를 불러와서 각 종별로 `setosa` `versicolor`,\n`virginica`로 나눠 로컬 `.csv` 파일로 저장하고 나서 이를 다시 불러오는\n사례를 함수형 프로그래밍으로 구현해본다.\n\n![붓꽃 데이터 불러오기](images/fp-iris.png)\n\n먼저 `iris.csv` 파일을 R로 불러와서 각 종별로 나눠서 `iris_종명.csv`\n파일형식으로 저장시킨다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\niris_df <- read_csv(\"https://gist.githubusercontent.com/curran/a08a1080b88344b0c8a7/raw/d546eaee765268bf2f487608c537c05e22e4b221/iris.csv\")\n\niris_species <- iris_df %>% \n  count(species) %>% pull(species)\n\nfor(i in 1:nrow(iris_df)) {\n  tmp_df <- iris_df %>% \n    filter(species == iris_species[i])\n  species_name <- iris_species[i]\n  tmp_df %>% write_csv(paste0(\"data/iris_\", species_name, \".csv\"))\n}\n\nSys.glob(\"data/iris_*.csv\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data/iris_NA.csv\"         \"data/iris_setosa.csv\"    \n[3] \"data/iris_versicolor.csv\" \"data/iris_virginica.csv\" \n```\n\n\n:::\n:::\n\n\n로컬 파일 `iris_종명.csv` 형식으로 저장된 데이터를 함수형 프로그래밍을\n통해 불러와서 분석작업을 수행해보자. `map()` 함수를 사용해서 각 종별로\n데이터를 깔끔하게 불러왔다.\n\n`iris_filename` 벡터에 `iris_종명.csv`과 경로명이 포함된 문자열을\n저장시켜 놓고 `read_csv()` 함수를 각 벡터 원소에 적용시켜 출력값으로\n리스트 `iris_list` 객체를 생성시켰다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris_filename <- c(\"data/iris_setosa.csv\", \"data/iris_versicolor.csv\", \"data/iris_virginica.csv\")\n\niris_list <- map(iris_filename, read_csv) %>% \n  set_names(iris_species)\n\niris_list |> enframe()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  name       value              \n  <chr>      <list>             \n1 setosa     <spc_tbl_ [50 × 5]>\n2 versicolor <spc_tbl_ [50 × 5]>\n3 virginica  <spc_tbl_ [50 × 5]>\n```\n\n\n:::\n:::\n\n\n`iris_list` 각 원소는 데이터프레임이라 `summary` 함수를 사용해서 기술\n통계량을 구할 수도 있다. 물론 `cor()` 함수를 사용해서 `iris_list`의 각\n원소를 지정하는 `.x` 여기서는 종별 데이터프레임에서 변수 두개를 추출하여\n`sepal_length`, `sepal_width` 이 둘간의 스피커만 상관계수를 계산하는데\n출력값이 `double` 연속형이라 `map_dbl`로 저정하여 작업시킨다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(iris_list, summary)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$setosa\n  sepal_length    sepal_width     petal_length    petal_width   \n Min.   :4.300   Min.   :2.300   Min.   :1.000   Min.   :0.100  \n 1st Qu.:4.800   1st Qu.:3.125   1st Qu.:1.400   1st Qu.:0.200  \n Median :5.000   Median :3.400   Median :1.500   Median :0.200  \n Mean   :5.006   Mean   :3.418   Mean   :1.464   Mean   :0.244  \n 3rd Qu.:5.200   3rd Qu.:3.675   3rd Qu.:1.575   3rd Qu.:0.300  \n Max.   :5.800   Max.   :4.400   Max.   :1.900   Max.   :0.600  \n   species         \n Length:50         \n Class :character  \n Mode  :character  \n                   \n                   \n                   \n\n$versicolor\n  sepal_length    sepal_width     petal_length   petal_width   \n Min.   :4.900   Min.   :2.000   Min.   :3.00   Min.   :1.000  \n 1st Qu.:5.600   1st Qu.:2.525   1st Qu.:4.00   1st Qu.:1.200  \n Median :5.900   Median :2.800   Median :4.35   Median :1.300  \n Mean   :5.936   Mean   :2.770   Mean   :4.26   Mean   :1.326  \n 3rd Qu.:6.300   3rd Qu.:3.000   3rd Qu.:4.60   3rd Qu.:1.500  \n Max.   :7.000   Max.   :3.400   Max.   :5.10   Max.   :1.800  \n   species         \n Length:50         \n Class :character  \n Mode  :character  \n                   \n                   \n                   \n\n$virginica\n  sepal_length    sepal_width     petal_length    petal_width   \n Min.   :4.900   Min.   :2.200   Min.   :4.500   Min.   :1.400  \n 1st Qu.:6.225   1st Qu.:2.800   1st Qu.:5.100   1st Qu.:1.800  \n Median :6.500   Median :3.000   Median :5.550   Median :2.000  \n Mean   :6.588   Mean   :2.974   Mean   :5.552   Mean   :2.026  \n 3rd Qu.:6.900   3rd Qu.:3.175   3rd Qu.:5.875   3rd Qu.:2.300  \n Max.   :7.900   Max.   :3.800   Max.   :6.900   Max.   :2.500  \n   species         \n Length:50         \n Class :character  \n Mode  :character  \n                   \n                   \n                   \n```\n\n\n:::\n\n```{.r .cell-code}\nmap_dbl(iris_list, ~cor(.x$sepal_length, .x$sepal_width, method = \"spearman\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    setosa versicolor  virginica \n 0.7686085  0.5176060  0.4265165 \n```\n\n\n:::\n:::\n\n\n## 표본추출 {#functional-programming-purrr-random-number}\n\n서로 다른 난수를 생성시키는 방법을 살펴보자. 정규분포를 가정하고 평균과\n표준편차를 달리하는 모수를 지정하고 난수갯수도 숫자를 달리하여 난수를\n생성시킨다.\n\n### $\\mu$ 평균 변화 {#functional-programming-purrr-random-number-mean}\n\n정규분포에서 난수를 10개 추출하는데 표준편차는 1로 고정시키고, 평균만\n달리한다. 평균만 달리하기 때문에 `map()` 함수를 그대로 사용한다. 즉,\n입력값으로 평균만 달리하는 리스트를 입력값으로 넣는다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## 평균을 달리하는 경우\nnormal_mean <- list(1,5,10)\n\nsim_mu_name <- paste0(\"mu: \", normal_mean)\n\nsim_mu_list <- map(normal_mean, ~ data.frame(mean = .x, \n                            random_number = rnorm(mean=.x, sd=1, n=10))) %>% \n  set_names(sim_mu_name)\n\nmap_dbl(sim_mu_list, ~mean(.x$random_number))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    mu: 1     mu: 5    mu: 10 \n 1.027545  5.016667 10.271774 \n```\n\n\n:::\n\n```{.r .cell-code}\nsim_mu_list |> enframe()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  name   value        \n  <chr>  <list>       \n1 mu: 1  <df [10 × 2]>\n2 mu: 5  <df [10 × 2]>\n3 mu: 10 <df [10 × 2]>\n```\n\n\n:::\n:::\n\n\n### $\\mu$ 평균, $\\sigma$ 표준편차 {#functional-programming-purrr-random-number-mean-sd}\n\n난수갯수만 고정시키고 평균과 표준편차를 달리하여 난수를 정규분포에서\n추출한다. 입력값으로 평균과 표준편차 두개가 되기 때문에 `map2()` 함수를\n사용한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## 평균과 표준편차를 달리하는 경우\nnormal_mean <- list(1,5,10)\nnormal_sd   <- list(10,5,1)\n\nsim_mu_sd_name <- paste0(\"mu: \", normal_mean, \",  sd: \", normal_sd)\n\nsim_mu_sd_list <- map2(normal_mean, normal_sd, \n                        ~ data.frame(mean = .x, sd = .y,\n                            random_number = rnorm(mean=.x, sd=.y, n=10))) %>% \n  set_names(sim_mu_sd_name)\n\nmap_dbl(sim_mu_sd_list, ~sd(.x$random_number))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nmu: 1,  sd: 10  mu: 5,  sd: 5 mu: 10,  sd: 1 \n      9.093706       3.150940       1.170196 \n```\n\n\n:::\n\n```{.r .cell-code}\nsim_mu_sd_list |> enframe()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  name           value        \n  <chr>          <list>       \n1 mu: 1,  sd: 10 <df [10 × 3]>\n2 mu: 5,  sd: 5  <df [10 × 3]>\n3 mu: 10,  sd: 1 <df [10 × 3]>\n```\n\n\n:::\n:::\n\n\n### $\\mu$, $\\sigma$, 표본크기 {#functional-programming-purrr-random-number-mean-sd-size}\n\n$\\mu$ 평균, $\\sigma$ 표준편차, 표본크기를 모두 다르게 지정하여 난수를\n추출한다. 이런 경우 `pmap()` 함수를 사용하고 입력 리스트가 다수라 이를\n`normal_list`로 한번더 감싸서 이름이 붙은 리스트(named list)형태로\n넣어주고, 이를 `function()` 함수의 내부 인수로 사용한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## 평균, 표준편차, 표본크기를 달리하는 경우\nnormal_mean <- list(1,5,10)\nnormal_sd   <- list(10,5,1)\nnormal_size <- list(10,20,30)\n\nsim_mu_sd_size_name <- paste0(\"mu: \", normal_mean, \",  sd: \", normal_sd,\n                              \"  size: \", normal_size)\n\nnormal_list <- list(normal_mean=normal_mean, normal_sd=normal_sd, normal_size=normal_size)\n\nsim_mu_sd_size_list <- pmap(normal_list,\n                            function(normal_mean, normal_sd, normal_size)\n                        data.frame(mean=normal_mean, sd = normal_sd, size = normal_size,\n                            random_number = rnorm(mean=normal_mean, sd=normal_sd, n=normal_size))) %>% \n  set_names(sim_mu_sd_size_name)\n\nmap_dbl(sim_mu_sd_size_list, ~length(.x$random_number))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nmu: 1,  sd: 10  size: 10  mu: 5,  sd: 5  size: 20 mu: 10,  sd: 1  size: 30 \n                      10                       20                       30 \n```\n\n\n:::\n\n```{.r .cell-code}\nsim_mu_sd_size_list |> enframe()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  name                     value        \n  <chr>                    <list>       \n1 mu: 1,  sd: 10  size: 10 <df [10 × 4]>\n2 mu: 5,  sd: 5  size: 20  <df [20 × 4]>\n3 mu: 10,  sd: 1  size: 30 <df [30 × 4]>\n```\n\n\n:::\n:::\n\n\n## `ggplot` 시각화 {#functional-programming-purrr-ggplot}\n\n`list-column`을 활용하여 티블(tibble) 데이터프레임에 담아서 시각화를\n진행해도 되고, 다른 방법으로 리스트에 담아서 이를 한장에 찍는 것도\n가능하다. [^functions_purrr-4]\n\n[^functions_purrr-4]: [Very statisticious (August 20, 2018), \"Automating\n    exploratory plots with ggplot2 and\n    purrr\"](https://aosmith.rbind.io/2018/08/20/automating-exploratory-plots/)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(gapminder)\n\n## 데이터 -----\nthree_country <-  c(\"Korea, Rep.\", \"Japan\", \"China\")\n\ngapminder_tbl <- gapminder %>% \n  filter(str_detect(continent, \"Asia\")) %>% \n  group_by(continent, country) %>% \n  nest() %>% \n  select(-continent) %>% \n  filter(country %in% three_country )\n\n## 티블 데이터 시각화 -----\ngapminder_plot_tbl <- gapminder_tbl %>% \n  mutate(graph = map2(data, country, \n                     ~ggplot(.x, aes(x=year, y=gdpPercap)) +\n                       geom_line() +\n                       labs(title=.y)))\n\ngapminder_plot_tbl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 4\n# Groups:   continent, country [3]\n  continent country     data              graph \n  <fct>     <fct>       <list>            <list>\n1 Asia      China       <tibble [12 × 4]> <gg>  \n2 Asia      Japan       <tibble [12 × 4]> <gg>  \n3 Asia      Korea, Rep. <tibble [12 × 4]> <gg>  \n```\n\n\n:::\n\n```{.r .cell-code}\n## 리스트 데이터 시각화 -----\ngapminder_plot <- map2(gapminder_tbl$data , three_country, \n                     ~ggplot(.x, aes(x=year, y=gdpPercap)) +\n                       geom_line() +\n                       labs(title=.y))\n\nwalk(gapminder_plot, print)\n```\n\n::: {.cell-output-display}\n![](functions_purrr_files/figure-html/fp-iris-viz-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](functions_purrr_files/figure-html/fp-iris-viz-2.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](functions_purrr_files/figure-html/fp-iris-viz-3.png){width=672}\n:::\n\n```{.r .cell-code}\n## 리스트 데이터 시각화 - 한장에 찍기 -----\ncowplot::plot_grid(plotlist = gapminder_plot)\n```\n\n::: {.cell-output-display}\n![](functions_purrr_files/figure-html/fp-iris-viz-4.png){width=672}\n:::\n:::\n\n\n## 함수형 프로그래밍 이론과 실제 {#fp-theory-practice}\n\n함수는 다음과 같이 될 수도 있어 함수형 프로그래밍 언어가 된다.\n[^functions_purrr-5]\n\n[^functions_purrr-5]: [Advanced R,\n    \"Introduction\"](https://adv-r.hadley.nz/fp.html)\n\n-   함수의 인자\n-   함수로 반환\n-   리스트에 저장\n-   변수에 저장\n-   무명함수\n-   조작할 수 있다.\n\nFirstly, functional languages have first-class functions, functions that\nbehave like any other data structure. In R, this means that you can do\nanything with a function that you can do with a vector: you can assign\nthem to variables, store them in lists, pass them as arguments to other\nfunctions, create them inside functions, and even return them as the\nresult of a function.\n\n::: callout-note\n### John Chambers 창시자가 말하는 R 계산의 기본원칙\n\n-   존재하는 모든 것은 객체다. (Everything that exists is an object.)\n-   일어나는 모든 것은 함수호출이다. (Everything that happens is a\n    function call.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nclass(`%>%`)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"function\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(`$`)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"function\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(`<-`)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"function\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(`+`)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"function\"\n```\n\n\n:::\n:::\n\n:::\n\n## 순수한 함수 vs 불순한 함수 {#pure-vs-impure-function}\n\n**순수한 함수(pure function)**는 입력값에만 출력값이 의존하게 되는\n특성과 부수효과(side-effect)를 갖지 않는 반면 **순수하지 않은\n함수(impure function)**는 환경에 의존하며 부수효과도 갖는다.\n\n::: columns\n::: column\n**순수한 함수(pure function)**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmin(1:100)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(1:100)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 50.5\n```\n\n\n:::\n:::\n\n:::\n\n::: column\n**순수하지 않은 함수(impure function)**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSys.time()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2024-01-28 21:49:56 KST\"\n```\n\n\n:::\n\n```{.r .cell-code}\nrnorm(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  0.7124784 -1.5636042 -0.1669109 -0.4684979  0.5287181 -1.1670593\n [7]  0.1715563 -0.5630649 -0.2030090 -0.5322956\n```\n\n\n:::\n\n```{.r .cell-code}\n# write_csv(\"data/sample.csv\")\n```\n:::\n\n:::\n:::\n\n### 무명함수와 매퍼 {#fp-lambda-functin}\n\n$\\lambda$ (람다) 함수는 무명(anonymous) 함수는 함수명을 갖는 일반적인\n함수와 비교하여 함수의 좋은 점은 그대로 누리면서 함수가 많아 함수명으로\n메모리가 난잡하게 지져분해지는 것을 막을 수 있다.\n\n무명함수로 기능르 구현한 후에 매퍼(mapper)를 사용해서 `as_mapper()`\n명칭을 부여하여 함수처럼 사용하는 것도 가능하다. 매퍼(mapper)를 사용하는\n이유를 다음과 같이 정리할 수 있다.\n\n-   간결함(Concise)\n-   가독성(Easy to read)\n-   재사용성(Reusable)\n\n정치인 페이스북 페이지에서 팬수를 추출한다. 그리고 이를 이름이 부은\n리스트(named list)로 일자별 팬수 추이를 리스트로 준비한다. 그리고 나서\n안철수, 문재인, 심상정 세 후보에 대한 최고 팬수증가를 무명함수로\n계산한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n## 데이터프레임을 리스트로 변환\nahn_df  <- read_csv(\"data/fb_ahn.csv\")  %>% rename(fans = ahn_fans) %>% \n  mutate(fans_lag = lag(fans),\n         fans_diff = fans - fans_lag) %>% \n  select(fdate, fans = fans_diff) %>% \n  filter(!is.na(fans))\nmoon_df <- read_csv(\"data/fb_moon.csv\") %>% rename(fans = moon_fans) %>% \n  mutate(fans_lag = lag(fans),\n         fans_diff = fans - fans_lag) %>% \n  select(fdate, fans = fans_diff) %>% \n  filter(!is.na(fans))\nsim_df  <- read_csv(\"data/fb_sim.csv\")  %>% rename(fans = sim_fans) %>% \n  mutate(fans_lag = lag(fans),\n         fans_diff = fans - fans_lag) %>% \n  select(fdate, fans = fans_diff) %>% \n  filter(!is.na(fans))\n\nconvert_to_list <- function(df) {\n  df_fans_v <- df$fans %>% \n    set_names(df$fdate)\n  return(df_fans_v)\n}\n\nahn_v  <- convert_to_list(ahn_df)\nmoon_v <- convert_to_list(moon_df)\nsim_v  <- convert_to_list(sim_df)\n\nfans_lst <- list(ahn_fans  = ahn_v,\n                 moon_fans = moon_v,\n                 sim_fans  = sim_v)\n\nlistviewer::jsonedit(fans_lst)\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"jsonedit html-widget html-fill-item\" id=\"htmlwidget-6eac27a2651ca6d5413d\" style=\"width:100%;height:464px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-6eac27a2651ca6d5413d\">{\"x\":{\"data\":{\"ahn_fans\":{\"2017-01-02\":4,\"2017-01-03\":31,\"2017-01-04\":33,\"2017-01-05\":290,\"2017-01-06\":140,\"2017-01-07\":61,\"2017-01-08\":34,\"2017-01-09\":38,\"2017-01-10\":40,\"2017-01-11\":24,\"2017-01-12\":45,\"2017-01-13\":30,\"2017-01-14\":29,\"2017-01-15\":17,\"2017-01-16\":26,\"2017-01-17\":17,\"2017-01-18\":23,\"2017-01-19\":66,\"2017-01-20\":45,\"2017-01-21\":22,\"2017-01-22\":37,\"2017-01-23\":52,\"2017-01-24\":21,\"2017-01-25\":80,\"2017-01-26\":47,\"2017-01-27\":51,\"2017-01-28\":77,\"2017-01-29\":69,\"2017-01-30\":580,\"2017-01-31\":63,\"2017-02-01\":32,\"2017-02-02\":144,\"2017-02-03\":43,\"2017-02-04\":106,\"2017-02-05\":65,\"2017-02-06\":86,\"2017-02-07\":112,\"2017-02-08\":63,\"2017-02-09\":69,\"2017-02-10\":92,\"2017-02-11\":38,\"2017-02-12\":14,\"2017-02-13\":15,\"2017-02-14\":63,\"2017-02-15\":28,\"2017-02-16\":252,\"2017-02-17\":115,\"2017-02-18\":74,\"2017-02-19\":38,\"2017-02-20\":46,\"2017-02-21\":61,\"2017-02-22\":57,\"2017-02-23\":71,\"2017-02-24\":445,\"2017-02-25\":299,\"2017-02-26\":147,\"2017-02-27\":87,\"2017-02-28\":91,\"2017-03-01\":32,\"2017-03-02\":50,\"2017-03-03\":37,\"2017-03-04\":89,\"2017-03-05\":64,\"2017-03-06\":55,\"2017-03-07\":51,\"2017-03-08\":38,\"2017-03-09\":34,\"2017-03-10\":183,\"2017-03-11\":157,\"2017-03-12\":141,\"2017-03-13\":125,\"2017-03-14\":105,\"2017-03-15\":155,\"2017-03-16\":178,\"2017-03-17\":135,\"2017-03-18\":135,\"2017-03-19\":183,\"2017-03-20\":183,\"2017-03-21\":144,\"2017-03-22\":174,\"2017-03-23\":181,\"2017-03-24\":153,\"2017-03-25\":135,\"2017-03-26\":240,\"2017-03-27\":226,\"2017-03-28\":241,\"2017-03-29\":190,\"2017-03-30\":175,\"2017-03-31\":258,\"2017-04-01\":283,\"2017-04-02\":252,\"2017-04-03\":239,\"2017-04-04\":430,\"2017-04-05\":796,\"2017-04-06\":744,\"2017-04-07\":581,\"2017-04-08\":509,\"2017-04-09\":409,\"2017-04-10\":591,\"2017-04-11\":444,\"2017-04-12\":333,\"2017-04-13\":189,\"2017-04-14\":233,\"2017-04-15\":238,\"2017-04-16\":212,\"2017-04-17\":320,\"2017-04-18\":636,\"2017-04-19\":516,\"2017-04-20\":629,\"2017-04-21\":484,\"2017-04-22\":385,\"2017-04-23\":676,\"2017-04-24\":469,\"2017-04-25\":289},\"moon_fans\":{\"2017-01-02\":413,\"2017-01-03\":397,\"2017-01-04\":465,\"2017-01-05\":381,\"2017-01-06\":511,\"2017-01-07\":645,\"2017-01-08\":350,\"2017-01-09\":264,\"2017-01-10\":236,\"2017-01-11\":260,\"2017-01-12\":419,\"2017-01-13\":570,\"2017-01-14\":356,\"2017-01-15\":372,\"2017-01-16\":306,\"2017-01-17\":386,\"2017-01-18\":570,\"2017-01-19\":370,\"2017-01-20\":414,\"2017-01-21\":207,\"2017-01-22\":378,\"2017-01-23\":690,\"2017-01-24\":558,\"2017-01-25\":373,\"2017-01-26\":452,\"2017-01-27\":438,\"2017-01-28\":301,\"2017-01-29\":267,\"2017-01-30\":347,\"2017-01-31\":192,\"2017-02-01\":237,\"2017-02-02\":647,\"2017-02-03\":554,\"2017-02-04\":559,\"2017-02-05\":550,\"2017-02-06\":467,\"2017-02-07\":463,\"2017-02-08\":329,\"2017-02-09\":142,\"2017-02-10\":296,\"2017-02-11\":144,\"2017-02-12\":163,\"2017-02-13\":107,\"2017-02-14\":114,\"2017-02-15\":80,\"2017-02-16\":250,\"2017-02-17\":114,\"2017-02-18\":162,\"2017-02-19\":61,\"2017-02-20\":40,\"2017-02-21\":72,\"2017-02-22\":23,\"2017-02-23\":17,\"2017-02-24\":13,\"2017-02-25\":12,\"2017-02-26\":52,\"2017-02-27\":75,\"2017-02-28\":129,\"2017-03-01\":12,\"2017-03-02\":61,\"2017-03-03\":72,\"2017-03-04\":56,\"2017-03-05\":285,\"2017-03-06\":184,\"2017-03-07\":3,\"2017-03-08\":-9,\"2017-03-09\":14,\"2017-03-10\":733,\"2017-03-11\":322,\"2017-03-12\":245,\"2017-03-13\":123,\"2017-03-14\":98,\"2017-03-15\":73,\"2017-03-16\":278,\"2017-03-17\":121,\"2017-03-18\":76,\"2017-03-19\":-25,\"2017-03-20\":-44,\"2017-03-21\":88,\"2017-03-22\":455,\"2017-03-23\":257,\"2017-03-24\":188,\"2017-03-25\":166,\"2017-03-26\":77,\"2017-03-27\":45,\"2017-03-28\":1464,\"2017-03-29\":695,\"2017-03-30\":302,\"2017-03-31\":115,\"2017-04-01\":149,\"2017-04-02\":104,\"2017-04-03\":55,\"2017-04-04\":160,\"2017-04-05\":151,\"2017-04-06\":141,\"2017-04-07\":139,\"2017-04-08\":358,\"2017-04-09\":488,\"2017-04-10\":521,\"2017-04-11\":629,\"2017-04-12\":397,\"2017-04-13\":205,\"2017-04-14\":303,\"2017-04-15\":207,\"2017-04-16\":541,\"2017-04-17\":944,\"2017-04-18\":1310,\"2017-04-19\":732,\"2017-04-20\":1093,\"2017-04-21\":880,\"2017-04-22\":812,\"2017-04-23\":930,\"2017-04-24\":955,\"2017-04-25\":616},\"sim_fans\":{\"2017-01-02\":167,\"2017-01-03\":134,\"2017-01-04\":145,\"2017-01-05\":133,\"2017-01-06\":144,\"2017-01-07\":156,\"2017-01-08\":93,\"2017-01-09\":117,\"2017-01-10\":88,\"2017-01-11\":175,\"2017-01-12\":136,\"2017-01-13\":147,\"2017-01-14\":158,\"2017-01-15\":135,\"2017-01-16\":101,\"2017-01-17\":229,\"2017-01-18\":721,\"2017-01-19\":566,\"2017-01-20\":541,\"2017-01-21\":341,\"2017-01-22\":217,\"2017-01-23\":239,\"2017-01-24\":302,\"2017-01-25\":240,\"2017-01-26\":221,\"2017-01-27\":200,\"2017-01-28\":234,\"2017-01-29\":91,\"2017-01-30\":106,\"2017-01-31\":86,\"2017-02-01\":140,\"2017-02-02\":681,\"2017-02-03\":332,\"2017-02-04\":331,\"2017-02-05\":239,\"2017-02-06\":371,\"2017-02-07\":514,\"2017-02-08\":306,\"2017-02-09\":265,\"2017-02-10\":123,\"2017-02-11\":51,\"2017-02-12\":125,\"2017-02-13\":28,\"2017-02-14\":66,\"2017-02-15\":62,\"2017-02-16\":94,\"2017-02-17\":134,\"2017-02-18\":106,\"2017-02-19\":93,\"2017-02-20\":57,\"2017-02-21\":32,\"2017-02-22\":72,\"2017-02-23\":62,\"2017-02-24\":63,\"2017-02-25\":46,\"2017-02-26\":167,\"2017-02-27\":638,\"2017-02-28\":292,\"2017-03-01\":291,\"2017-03-02\":219,\"2017-03-03\":184,\"2017-03-04\":157,\"2017-03-05\":236,\"2017-03-06\":288,\"2017-03-07\":134,\"2017-03-08\":79,\"2017-03-09\":113,\"2017-03-10\":789,\"2017-03-11\":489,\"2017-03-12\":1301,\"2017-03-13\":1079,\"2017-03-14\":657,\"2017-03-15\":439,\"2017-03-16\":414,\"2017-03-17\":325,\"2017-03-18\":321,\"2017-03-19\":248,\"2017-03-20\":559,\"2017-03-21\":529,\"2017-03-22\":394,\"2017-03-23\":528,\"2017-03-24\":523,\"2017-03-25\":454,\"2017-03-26\":474,\"2017-03-27\":202,\"2017-03-28\":499,\"2017-03-29\":250,\"2017-03-30\":167,\"2017-03-31\":196,\"2017-04-01\":292,\"2017-04-02\":429,\"2017-04-03\":469,\"2017-04-04\":403,\"2017-04-05\":433,\"2017-04-06\":364,\"2017-04-07\":636,\"2017-04-08\":450,\"2017-04-09\":285,\"2017-04-10\":380,\"2017-04-11\":395,\"2017-04-12\":571,\"2017-04-13\":397,\"2017-04-14\":1070,\"2017-04-15\":975,\"2017-04-16\":755,\"2017-04-17\":671,\"2017-04-18\":806,\"2017-04-19\":1441,\"2017-04-20\":1190,\"2017-04-21\":1025,\"2017-04-22\":950,\"2017-04-23\":896,\"2017-04-24\":1948,\"2017-04-25\":2029}},\"options\":{\"mode\":\"tree\",\"modes\":[\"text\",\"tree\",\"table\"]}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n\n```{.r .cell-code}\n## 무명함수 테스트\nmap_dbl(fans_lst, ~max(.x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n ahn_fans moon_fans  sim_fans \n      796      1464      2029 \n```\n\n\n:::\n:::\n\n\n`rlang_lambda_function` 무명함수로 `increase_1000_fans` 작성해서 일별\n팬수 증가가 1000명 이상인 경우 `keep()` 함수를 사용해서 각 후보별로\n추출할 수 있다. `discard()` 함수를 사용해서 반대로 버려버릴 수도 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nincrease_1000_fans <- as_mapper( ~.x > 1000)\n\nmap(fans_lst, ~keep(.x, increase_1000_fans))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$ahn_fans\nnamed numeric(0)\n\n$moon_fans\n2017-03-28 2017-04-18 2017-04-20 \n      1464       1310       1093 \n\n$sim_fans\n2017-03-12 2017-03-13 2017-04-14 2017-04-19 2017-04-20 2017-04-21 2017-04-24 \n      1301       1079       1070       1441       1190       1025       1948 \n2017-04-25 \n      2029 \n```\n\n\n:::\n:::\n\n\n[술어논리(predicate\nlogic)](https://terms.naver.com/entry.nhn?docId=1116302&cid=40942&categoryId=31530)은\n조건을 테스트하여 참(`TRUE`), 거짓(`FALSE`)을 반환시킨다. `every`,\n`some`을 사용하여 팬수가 증가한 날이 매일 1,000명이 증가했는지, 전부는\n아니고 일부 특정한 날에 1,000명이 증가했는지 파악할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## 세후보 팬수가 매일 모두 1000명 이상 증가했나요?\nmap(fans_lst, ~every(.x, increase_1000_fans))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$ahn_fans\n[1] FALSE\n\n$moon_fans\n[1] FALSE\n\n$sim_fans\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n## 세후보 팬수가 전체는 아니고 일부 특정한 날에 1000명 이상 증가했나요?\nmap(fans_lst, ~some(.x, increase_1000_fans))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$ahn_fans\n[1] FALSE\n\n$moon_fans\n[1] TRUE\n\n$sim_fans\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n### 고차 함수(High order function) {#high-order-function}\n\n고차 함수(High order function)는 함수의 인자로 함수를 받아 함수로\n반환시키는 함수를 지칭한다. `high_order_fun` 함수는 함수를\n인자(`func`)로 받아 함수를 반환시키는 고차함수다. 평균 함수(`mean`)를\n인자로 넣어 출력값으로 `mean_na()` 함수를 새롭게 생성시킨다. `NA`가\n포함된 벡터를 넣어 평균값을 계산하게 된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhigh_order_fun <- function(func){\n  function(...){\n    func(..., na.rm = TRUE)\n  }\n}\n\nmean_na <- high_order_fun(mean)\nmean_na( c(NA, 1:10) )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.5\n```\n\n\n:::\n:::\n\n\n벡터가 입력값으로 들어가서 벡터가 출력값으로 나오는 보통 함수(Regular\nFunction)외에 고차함수는 3가지 유형이 있다.\n\n-   벡터 → 함수: 함수공장(Function Factory)\n-   함수 → 벡터: Functional - `for`루프를 `purrr` 팩키지 `map()` 함수로\n    대체\n-   함수 → 함수: 함수연산자(Function Operator) - `Functional`과 함께\n    사용될 경우 `adverbs`로서 강력한 기능을 발휘\n\n![고차함수 유형](images/fp.png){fig-align=\"center\" width=\"416\"}\n\n### 부사 - `safely`, `possibly`,... {#adverbs-safely-possibly}\n\n`purrr` 팩키지의 대표적인 부사(adverbs)에는 `possibly()`와 `safely()`가\n있다. 그외에도 `silently()`, `surely()` 등 다른 부사도 있으니 필요한\n경우 `purrr` 팩키지 문서를 참조한다.\n\n`safely(mean)`은 동사 함수(`mean()`)를 받아 부사 `safely()`로 \"부사 +\n동사\"로 기능이 추가된 부사 동사를 반환시킨다. 따라서, `NA`가 추가된\n벡터를 넣을 경우 `$result`와 `$error`를 원소로 갖는 리스트를 반환시킨다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_safe <- safely(mean)\nclass(mean_safe)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"function\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmean_safe(c(NA, 1:10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$result\n[1] NA\n\n$error\nNULL\n```\n\n\n:::\n:::\n\n\n이를 활용하여 오류처리작업을 간결하게 수행시킬 수 있다. `$result`와\n`$error`을 원소로 갖는 리스트를 반환시키기 때문에 오류와 결과값을\n추출하여 후속작업을 수행하여 디버깅하는데 유용하게 활용할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_lst <- list(\"NA\", 1,2,3,4,5)\nlog_safe <- safely(log)\n\nmap(test_lst, log_safe) %>% \n  map(\"result\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\nNULL\n\n[[2]]\n[1] 0\n\n[[3]]\n[1] 0.6931472\n\n[[4]]\n[1] 1.098612\n\n[[5]]\n[1] 1.386294\n\n[[6]]\n[1] 1.609438\n```\n\n\n:::\n\n```{.r .cell-code}\nmap(test_lst, log_safe) %>% \n  map(\"error\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n<simpleError in .Primitive(\"log\")(x, base): 수학함수에 숫자가 아닌 인자가 전달되었습니다>\n\n[[2]]\nNULL\n\n[[3]]\nNULL\n\n[[4]]\nNULL\n\n[[5]]\nNULL\n\n[[6]]\nNULL\n```\n\n\n:::\n:::\n\n\n반면에 `possibly()`는 결과와 `otherwise` 값을 반환시켜서 오류가 발생되면\n중단되는 것이 아니라 오류가 있다는 사실을 알고 예외처리시킨 후에 쭉\n정상진행시킨다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmax_possibly <- possibly(sum, otherwise = \"watch out\")\n\nmax_possibly(c(1:10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 55\n```\n\n\n:::\n\n```{.r .cell-code}\nmax_possibly(c(NA, 1:10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nmax_possibly(c(\"NA\", 1:10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"watch out\"\n```\n\n\n:::\n:::\n\n\n`possibly()`는 부울 논리값, `NA`, 문자열, 숫자를 반환시킬 수 있다.\n\n`transpose()`와 결합하여 `safely()`, `possibly()` 결과를 변형시킬 수도\n있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap(test_lst, log_safe) %>% length()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n\n```{.r .cell-code}\nmap(test_lst, log_safe) %>% transpose() %>% length()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n`compact()`를 사용해서 `NULL`을 제거하는데, 앞서 `possibly()`의 인자로\n`otherwise=`를 지정하는 경우 `otherwise=NULL`와 같이 정의해서 예외처리로\n`NULL`을 만들어 내고 `compact()`로 정상처리된 데이터만 얻는 작업흐름을\n갖춘다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnull_lst <- list(1, NULL, 3, 4, NULL, 6, 7, NA)\ncompact(null_lst)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] 3\n\n[[3]]\n[1] 4\n\n[[4]]\n[1] 6\n\n[[5]]\n[1] 7\n\n[[6]]\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\npossibly_log <- possibly(log, otherwise = NULL)\nmap(null_lst, possibly_log) %>% compact()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 0\n\n[[2]]\n[1] 1.098612\n\n[[3]]\n[1] 1.386294\n\n[[4]]\n[1] 1.791759\n\n[[5]]\n[1] 1.94591\n\n[[6]]\n[1] NA\n```\n\n\n:::\n:::\n\n\n## 깨끗한 코드 {#fp-clean-code}\n\n`round_mean()` 함수를 `compose()` 함수를 사용해서 `mean()` 함수로 평균을\n구한 후에 `round()`함수로 반올림하는 코드를 다음과 같이 쉽게 작성할 수\n있다. [^functions_purrr-6]\n\n[^functions_purrr-6]: [Colin Fay, \"A Crazy Little Thing Called {purrr} -\n    Part 5: code optimization\"](https://colinfay.me/purrr-code-optim/)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround_mean <- compose(round, mean)\nround_mean(1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n:::\n\n\n두번째 사례로 전형적인 데이터 분석 사례로 `lm()` → `anova()` →\n`tidy()`를 통해 한방에 선형회귀 모형 산출물을 깨끗한 코드로 작성하는\n사례를 살펴보자.\n\n`mtcars` 데이터셋에서 연비 예측에 변수 두개를 넣고 일반적인 `lm()`\n선형예측모형 제작방식과 동일하게 인자를 넣는다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclean_lm <- compose(broom::tidy, anova, lm)\nclean_lm(mpg ~ hp + wt, data=mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 6\n  term         df sumsq meansq statistic   p.value\n  <chr>     <int> <dbl>  <dbl>     <dbl>     <dbl>\n1 hp            1  678. 678.       101.   5.99e-11\n2 wt            1  253. 253.        37.6  1.12e- 6\n3 Residuals    29  195.   6.73      NA   NA       \n```\n\n\n:::\n:::\n\n\n`compose()`를 통해 함수를 조합하는 경우 함수의 인자를 함께 전달해야될\n경우가 있다. 이와 같은 경우 `partial()`을 사용해서 인자를 넘기는 함수를\n제작하여 `compose()`에 넣어준다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrobust_round_mean <- compose(\n  partial(round, digits=1),\n  partial(mean, na.rm=TRUE))\nrobust_round_mean(c(NA, 1:10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.5\n```\n\n\n:::\n:::\n\n\n리스트 칼럼(list-column)과 결합하여 모형에서 나온 데이터 분석결과를\n깔끔하게 코드로 제작해보자. 먼저 `lm`을 돌려 모형 요약하는 함수\n`summary`를 통해 `r.squared`값을 추출하는 함수를 `summary_lm`으로\n제작한다.\n\n그리고 나서 `nest()` 함수로 리스트 칼럼(list-column)을 만들고 두개의\n집단 수동/자동을 나타내는 `am` 변수를 그룹으로 삼아 두 집단에 속한\n수동/자동 데이터에 대한 선형 회귀모형을 적합시키고 나서 \"r.squared\"값을\n추출하여 이를 티블 데이터프레임에 저장시킨다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary_lm <- compose(summary, lm) \n\nmtcars %>%\n  group_by(am) %>%\n  nest() %>%\n  mutate(lm_mod = map(data, ~ summary_lm(mpg ~ hp + wt, data = .x)),\n         r_squared = map(lm_mod, \"r.squared\")) %>%\n  unnest(r_squared)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 4\n# Groups:   am [2]\n     am data               lm_mod     r_squared\n  <dbl> <list>             <list>         <dbl>\n1     1 <tibble [13 × 10]> <smmry.lm>     0.837\n2     0 <tibble [19 × 10]> <smmry.lm>     0.768\n```\n\n\n:::\n:::\n",
    "supporting": [
      "functions_purrr_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"site_libs/htmlwidgets-1.6.4/htmlwidgets.js\"></script>\n<script src=\"site_libs/jsoneditor-0.18.7/jsoneditor.min.js\"></script>\n<script src=\"site_libs/jsonedit-binding-4.0.0/jsonedit.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}