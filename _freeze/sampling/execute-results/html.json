{
  "hash": "191dca8a651348188538c2234a5e6ad5",
  "result": {
    "engine": "knitr",
    "markdown": "---\noutput: html_document\neditor_options: \n  chunk_output_type: console\n---\n\n\n# 표본 추출\n\n## 병원비 추정  {#밀린_병원비_추정}\n\n모집단이 1,000명($N=1,000$) 환자 중에서 임의표본추출로 200명($n=200$)을 뽑았다.\n병원에 484계정($N=484$) 중에서 9계정($n=9$)을 임의표본추출 방식으로 뽑아서, 평균적으로 얼마의 병원비가 밀렸는지 추정하고자 한다.\n이를 위해서 표본 9명을 뽑아서 밀린 평균 병원비를 조사해 보니 다음과 같다. [^survey-elementary-sampling]\n\n[^survey-elementary-sampling]: [Richard L. Scheaffer, III  William Mendenhall, R. Lyman Ott, Kenneth G. Gerow - \"Elementary Survey Sampling\"](https://www.amazon.com/Elementary-Survey-Sampling-Richard-Scheaffer/dp/0840053614)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nhosp_df <- tribble(\n    ~account, ~amount,\n\"y1\", 33.50,\n\"y2\", 32.00,\n\"y3\", 52.00,\n\"y4\", 43.00,\n\"y5\", 40.00,\n\"y6\", 41.00,\n\"y7\", 45.00,\n\"y8\", 42.50,\n\"y9\", 39.00)\n\nhosp_df %>% \n    summarise(amount_est = mean(amount),\n              amount_var = var(amount))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  amount_est amount_var\n       <dbl>      <dbl>\n1       40.9       35.7\n```\n\n\n:::\n:::\n\n\n이를 바탕으로 밀린 평균병원비를 추정해 보자.\n계정 9개로부터 나온 평균 병원비는 다음 공식으로 통해서 계산이 가능하다.\n\n$$\\bar{y} = \\frac{\\sum_{i=1}^{9}y_i}{9} = \\frac{368}{9} = 40.89 $$\n\n추정치의 오차를 계산하기 위해서 표본분산을 다음과 같이 먼저 계산한다.\n\n$$s^2 = \\frac{\\sum_{i=1}^{n} (y_i - \\bar{y})^2} {n-1} = 35.67 $$\n\n그리고 나서, 추정오차의 한계를 다음과 같이 구한다.\n\n- $N$: 1,000\n- $n$: 200\n- $s^2$: 445.21\n\n$$2 \\sqrt{\\hat{V}(\\bar{y})} = 2 \\sqrt{(1- \\frac{n}{N}) \\frac{s^2}{n}} = 2 \\sqrt{(1- \\frac{200}{1000}) \\frac{445.21}{200}} = 3.94$$\n\n따라서 평균적으로 밀린 병원비 $\\mu = 40.89$으로 산출되는데 $\\mu$가 $\\bar{y}$와의 얼마나 가까운가를 나타내는 추정오차는 3.94로 산출해낼 수 있다.\n\n:::{.callout-note}\n\n비복원 추출 때문에 발생되는 분산의 감소량을 **FPC(유한모집단수정, Finite population correction)**로 나타내는데,\n복원추출인 경우 FPC는 없어지고, 모집단 $N$이 매우 커서 $n$이 작은 경우 $\\frac{n}{N} \\approx 0$, 따라서,\n$1 - \\frac{n}{N} \\approx 1$이 된다.\n\n:::\n\n\n## 표본추출 {#basic-concept}\n\n### 커피 데이터 {#coffee-dataset}\n\n[`qacData`](https://github.com/rkabacoff/qacData/) 팩키지에 커피 리뷰 데이터가 포함되어 있다.\n`coffee` 데이터는 Coffee Quality Institute Database 에서 1312 아라비카 커피콩을 스크래핑하여 구축되었으며 수많은 리뷰어가 커피맛을 보고 평가를 내린 평점도 포함되어 있다. Tidy Tuesday에도 [커피맛 평가](https://github.com/rfordatascience/tidytuesday/blob/master/data/2020/2020-07-07/readme.md) 데이터가 동일하게 이용가능하다.\n\n커피콩은 커피나무의 씨앗이며 음용 커피의 재료로 사용되는데 경제적으로 가장 중요한 커피나무의 두 종으로는 아라비카와 로부스타가 있으며 전 세계에서 생산되는 커피 중 75~80%가 아라비카이고, 20%가 로부스타라는 통계가 있다. [^wiki-coffee]\n\n[^wiki-coffee]: [위키백과, \"커피콩\"](https://ko.wikipedia.org/wiki/커피콩)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(tidytuesdayR)\n\ntuesdata <- tidytuesdayR::tt_load(2020, week = 28)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tDownloading file 1 of 1: `coffee_ratings.csv`\n```\n\n\n:::\n\n```{.r .cell-code}\ncoffee <- tuesdata$coffee_ratings\n\ncoffee_df <- coffee %>% \n  select(total_cup_points, species, coo = country_of_origin, farm_name, aroma, body, balance, sweetness) %>% \n  filter(total_cup_points > 50)\n\nglimpse(coffee_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 1,338\nColumns: 8\n$ total_cup_points <dbl> 90.58, 89.92, 89.75, 89.00, 88.83, 88.83, 88.75, 88.6…\n$ species          <chr> \"Arabica\", \"Arabica\", \"Arabica\", \"Arabica\", \"Arabica\"…\n$ coo              <chr> \"Ethiopia\", \"Ethiopia\", \"Guatemala\", \"Ethiopia\", \"Eth…\n$ farm_name        <chr> \"metad plc\", \"metad plc\", \"san marcos barrancas \\\"san…\n$ aroma            <dbl> 8.67, 8.75, 8.42, 8.17, 8.25, 8.58, 8.42, 8.25, 8.67,…\n$ body             <dbl> 8.50, 8.42, 8.33, 8.50, 8.42, 8.25, 8.25, 8.33, 8.33,…\n$ balance          <dbl> 8.42, 8.42, 8.42, 8.25, 8.33, 8.33, 8.25, 8.50, 8.42,…\n$ sweetness        <dbl> 10.00, 10.00, 10.00, 10.00, 10.00, 10.00, 10.00, 9.33…\n```\n\n\n:::\n:::\n\n\n![](images/coffee-sampling.png)\n\n\n### 단순 임의추출 {#simple-random-sampling}\n\n단순 임의추출(Simple Random Sampling)은 모집단(Population) 혹은 표본 틀(Sampling Frame)에서 임의 방식으로 표본을 추출하는 것이다. `dplyr` 팩키지의 `slice_sample()` 함수를 사용하면 표본추출관련 대부분의 기능을 이를 통해서 구현할 수 있다.\n먼저 앞서 전세계 커피 품종에 대한 평가를 담을 데이터를 모집단으로 가정하고 임의로 10개를 커피콩을 추출해보자.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoffee_df %>% \n  slice_sample(n = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 8\n   total_cup_points species coo         farm_name  aroma  body balance sweetness\n              <dbl> <chr>   <chr>       <chr>      <dbl> <dbl>   <dbl>     <dbl>\n 1             81.2 Arabica Philippines irisan, b…  7.25  7.58    7.5         10\n 2             80.7 Arabica Colombia    <NA>        7.17  7.08    7.42        10\n 3             83.4 Arabica El Salvador la joya     7.58  7.75    7.67        10\n 4             80.3 Arabica Guatemala   la castel…  7.33  7       7.17        10\n 5             82.8 Arabica Guatemala   providenc…  7.5   7.58    7.5         10\n 6             80.7 Arabica Guatemala   chiquimul…  7     7       7.33        10\n 7             83.9 Arabica Mexico      finca san…  7.5   7.75    7.75        10\n 8             82.1 Arabica Brazil      rio verde   7.25  7.25    7.92        10\n 9             83.4 Arabica Thailand    matsuzawa…  7.5   7.75    7.67        10\n10             81.8 Arabica Brazil      rio verde   7.33  7.83    7.33        10\n```\n\n\n:::\n:::\n\n\n### 계통추출법 {#systematic-sampling}\n\n계통추출법(systematic sampling)은 첫 번째 요소는 무작위로 선정한 후, \n목록의 매번 k번째 요소를 표본으로 선정하는 표집방법이다. \n모집단의 크기를 원하는 표본의 크기로 나누어 k를 계산한다.\n이를 R을 통해 구현해보자.\n\n표본크기(`sample_size`) 10개를 추출한다. 이를 위해서 먼저 전체 표본 크기를 구한 후에 \n모집단을 표본크기로 나누는데 정수를 구해 간격(interval) `k`로 정하고 이를 \n행번호로 특정한 후에 `slice` 함수로 표본 추출한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample_size <- 10\npopulation_size <- nrow(coffee_df)\ninterval_k <- population_size %/% sample_size\n\nrow_index <- seq_len(sample_size) * interval_k\n\ncoffee_df %>% \n  rowid_to_column() %>% \n  slice(row_index)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 9\n   rowid total_cup_points species coo    farm_name aroma  body balance sweetness\n   <int>            <dbl> <chr>   <chr>  <chr>     <dbl> <dbl>   <dbl>     <dbl>\n 1   133             84.7 Arabica Costa… finca sa…  7.67  7.67    8.58     10   \n 2   266             83.9 Arabica Taiwan very fam…  7.75  7.75    7.67     10   \n 3   399             83.3 Arabica Colom… <NA>       7.83  7.5     7.58     10   \n 4   532             83   Arabica Nicar… santa ro…  7.58  7.92    8.08      9.33\n 5   665             82.5 Arabica Colom… <NA>       7.5   7.58    7.58     10   \n 6   798             82   Arabica Tanza… family f…  7.67  7.42    7.42     10   \n 7   931             81.5 Arabica Brazil sertao     7.5   7.5     7.33     10   \n 8  1064             80.6 Arabica Brazil rio verde  7.42  7.08    7.25     10   \n 9  1197             79.1 Arabica Mexico el desmo…  7.17  7.25    7.08     10   \n10  1330             80.5 Robusta Uganda mannya c…  7.75  7.67    7.58      7.67\n```\n\n\n:::\n:::\n\n\n상기 결과를 바탕으로 계통표본추출법으로 표본을 추출하는 함수를 제작해서 원하는 만큼 표본을 추출한다.\n하지만, 이런 경우 원데이터가 특정한 규칙을 내포한 경우 편의가 생길 수 있어 이를 보정하는 로직도 함께 넣어 둔다.\n`slice_sample(prop = 1)` 명령어는 데이터프레임을 마구 뒤섞어 혹시 생길 수 있는 편의를 제거하는 역할을 한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsystematic_sampling <- function(sample_size = 10) {\n  \n  sample_size <- sample_size\n  population_size <- nrow(coffee_df)\n  interval_k <- population_size %/% sample_size\n  \n  row_index <- seq_len(sample_size) * interval_k\n  \n  systematic_sample <- coffee_df %>% \n    slice_sample(prop = 1) %>% \n    rowid_to_column() %>% \n    slice(row_index)  \n  \n  return(systematic_sample)\n}\n\nsystematic_sampling(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 9\n  rowid total_cup_points species coo     farm_name aroma  body balance sweetness\n  <int>            <dbl> <chr>   <chr>   <chr>     <dbl> <dbl>   <dbl>     <dbl>\n1   446             83.8 Arabica Ethiop… phone nu…  7.58  7.83    7.5      10   \n2   892             81.5 Arabica Taiwan  good moo…  7.42  7.42    7.5       9.33\n3  1338             78   Arabica Colomb… <NA>       7.42  7.67    7.17      9.33\n```\n\n\n:::\n:::\n\n\n\n### 층화추출법 {#stratified-sampling}\n\n층화추출법(Stratified sampling)은 모집단을 먼저 중복되지 않도록 층으로 나눈 다음 각 층에서 표본을 추출하는 방법으로, 필요에 따라 각 층을 다시 하위층으로 나누어 추출하는 다단계 층화 추출을 하기도 한다.\n`dplyr` 팩키지를 사용할 경우 `slice_sample()` 함수를 하위 모집단 그룹, 즉 층(strata)으로 나눠 `group_by()`로 묶은 후에 임의 복원 혹은 비복원 임의추출방법을 수행한다.\n예를 들어, 원산지 국가를 기준으로 각 국가별로 3개 커피콩 품종을 추출하는 코드는 다음과 같다.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoffee_df %>% \n  group_by(coo) %>% \n  slice_sample(n = 3, replace = FALSE) %>% \n  arrange(coo)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 96 × 8\n# Groups:   coo [37]\n   total_cup_points species coo      farm_name     aroma  body balance sweetness\n              <dbl> <chr>   <chr>    <chr>         <dbl> <dbl>   <dbl>     <dbl>\n 1             83.2 Arabica Brazil   campo das fl…  7.75  7.58    7.58     10   \n 2             84.9 Arabica Brazil   fazenda grot…  8     8       7.75     10   \n 3             83.8 Arabica Brazil   rio verde      7.67  7.83    8.17      9.33\n 4             83.3 Arabica Burundi  sogestal kay…  7.75  7.5     7.75     10   \n 5             80.3 Arabica Burundi  <NA>           7.08  7.08    7.08     10   \n 6             87.2 Arabica China    echo coffee    8.42  7.92    8        10   \n 7             82.4 Arabica China    menglian gao…  7.67  7.42    7.42     10   \n 8             78.7 Arabica China    alicia's farm  7     7.17    7.17      9.33\n 9             84.2 Arabica Colombia <NA>           7.75  7.83    7.75     10   \n10             82.9 Arabica Colombia <NA>           7.58  7.67    7.58     10   \n# ℹ 86 more rows\n```\n\n\n:::\n:::\n\n\n### 집락추출법 {#cluster-sampling}\n\n집락추출법(Cluster Sampling)은 모집단에서 집단을 일차적으로 표집한 다음, 선정된 각 집단에서 구성원을 표본으로 추출하는 2단계 표본추출방법으로 다단계 표집방법의 특수한 경우다. 집락 내부는 이질적(heterogeneous)이고 집락 간에는 동질적(homogeneous) 특성을 가지도록 하는 것이 특징으로 이런 특성이 만족되어야 보다 큰 대표성을 갖게 된다.\n\n집락추출법을 통해 커피콩을 추출하는 방식은 먼저 전세계 국가에서 먼저 임의 국가로 표본크기를 3으로 정해 뽑은 후에 다시 이렇게 특정된 국가를 대상으로 2단계 커피콩 임의 추출작업을 수행한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## 1 단계 임의추출\ncountry <- coffee_df %>% \n  count(coo) %>% \n  pull(coo)\n\ncountry_sample <- sample(country, size = 3)\n\n## 2 단계 임의추출\ncoffee_df %>% \n  filter(coo %in% country_sample) %>% \n  slice_sample(n=5) %>% \n  arrange(coo)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 8\n  total_cup_points species coo      farm_name      aroma  body balance sweetness\n             <dbl> <chr>   <chr>    <chr>          <dbl> <dbl>   <dbl>     <dbl>\n1             81.6 Arabica Malawi   kavuzi          7.42  7.33    7.33        10\n2             81.2 Arabica Thailand <NA>            6.83  7.5     7.42        10\n3             84.8 Arabica Thailand matsuzawa cof…  7.75  8       7.75        10\n4             83.8 Arabica Thailand doi chaang co…  7.75  7.67    7.58        10\n5             82.9 Arabica Thailand doi tung deve…  7.42  7.5     8           10\n```\n\n\n:::\n:::\n\n\n\n## 표본추출 비교 {#basic-concept-comparison}\n\n결국 커피콩 데이터에서 추구하는 바는 `total_cup_points`를 가능하면 적은 비용과 노력으로 정확히 측정할 수 있도록 표본을 선정하는 것이다.\n\n### 모집단 {#basic-concept-comparison-population}\n\n먼저 모집단의 `total_cup_points` 평균을 구해서 이를 절대값으로 삼아 이야기를 풀어가도록 한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_population <- coffee_df %>% \n  summarise(mean_cup_points = mean(total_cup_points, na.rm = TRUE)) %>% \n  pull(mean_cup_points)\n\nmean_population\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 82.1512\n```\n\n\n:::\n:::\n\n\n### 임의추출법 {#basic-concept-comparison-srs}\n\n`slice_sample()` 함수를 통해 전체 모집단에서 10%를 임의로 추출하여 동일한 방식으로 `total_cup_points` 평균을 구해보자.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_srs <- coffee_df %>% \n  slice_sample(prop = 0.1) %>% \n  summarise(mean_cup_points = mean(total_cup_points, na.rm = TRUE)) %>% \n  pull(mean_cup_points)\n\nmean_srs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 82.34053\n```\n\n\n:::\n:::\n\n\n\n### 계통추출법 {#basic-concept-comparison-stratified}\n\n국가를 층(strata)으로 삼아 각 국가별로 10% 커피콩을 뽑아 `total_cup_points` 평균을 구해보자.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_stratified <- coffee_df %>% \n  group_by(coo) %>% \n  slice_sample(prop = 0.1) %>% \n  ungroup() %>% \n  summarise(mean_cup_points = mean(total_cup_points, na.rm = TRUE)) %>% \n  pull(mean_cup_points)\n\nmean_stratified\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 82.25276\n```\n\n\n:::\n:::\n\n\n### 집락추출법 {#basic-concept-comparison-cluster}\n\n다음은 전체 국가의 20%를 뽑고 각 국가별로 10%를 임의추출하는 2단계 표본추출법, \n즉 집락추출법을 사용해서 `total_cup_points` 평균을 구해보자.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## 1 단계 임의추출\ncountry_sample <- sample(country, size = length(country) %/% 5)\n\n## 2 단계 임의추출\nmean_cluster <- coffee_df %>% \n  filter(coo %in% country_sample) %>% \n  slice_sample(prop = 0.1) %>% \n  summarise(mean_cup_points = mean(total_cup_points, na.rm = TRUE)) %>% \n  pull(mean_cup_points)\n\nmean_cluster\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 80.12235\n```\n\n\n:::\n:::\n\n\n\n## 오차 측정 {#calculate-errors}\n\n모집단 `total_cup_points` 평균과 비교하여 다양한 표본추출방법에 따라 차이가 나는데 이를 통해 상대 오차를 측정할 필요가 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nestimation_df <- tibble(\n  \"population\" = mean_population,\n  \"srs\"        = mean_srs,\n  \"stratifed\"  = mean_stratified,\n  \"cluster\"    = mean_cluster\n)\n\nestimation_df \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 4\n  population   srs stratifed cluster\n       <dbl> <dbl>     <dbl>   <dbl>\n1       82.2  82.3      82.3    80.1\n```\n\n\n:::\n:::\n\n\n모집단에서 추정값을 뺀 후 100을 곱해 상대오차(Relative Error)를 구해 추정값의 정확성을 상대적으로 비교할 수 있다.\n\n$$\\text{상대오차} = \\frac{ | \\text{모집단 측정값} - \\text{표본추출 추정값} | }{\\text{모집단 측정값}} \\times 100$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nestimation_df %>% \n  pivot_longer(col = everything(), names_to = \"method\", values_to = \"estimation\") %>% \n  mutate(relative_error = abs(mean_population - estimation) / mean_population * 100)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 3\n  method     estimation relative_error\n  <chr>           <dbl>          <dbl>\n1 population       82.2          0    \n2 srs              82.3          0.230\n3 stratifed        82.3          0.124\n4 cluster          80.1          2.47 \n```\n\n\n:::\n:::\n\n\n\n### 반복 표본추출 {#calculate-errors-many-times}\n\n임의추출방법을 통해 표본을 한번만 추출하는 대신 원하는 만큼 충분히 반복하고자 하면 어떨까? \n먼저 앞서 단순 임의추출방법을 다시 확인해보자. 10%의 표본을 추출하여 `total_cup_points` 평균을 계산한다. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_srs <- coffee_df %>% \n  slice_sample(prop = 0.1) %>% \n  summarise(mean_cup_points = mean(total_cup_points, na.rm = TRUE)) %>% \n  pull(mean_cup_points)\n\nmean_srs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 82.19165\n```\n\n\n:::\n:::\n\n\n`replicate()` 함수를 사용해서 앞서 정의한 단순 임의추출방법을 원하는 만큼 예를 들어 100회 수행하게 된다. 이를 통해서 10% 표본을 뽑아 `total_cup_points` 평균을 계산하는 작업을 100회 수행시킬 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsrs_100 <- replicate(\n  n = 100,\n  expr = coffee_df %>% \n  slice_sample(prop = 0.1) %>% \n  summarise(mean_cup_points = mean(total_cup_points, na.rm = TRUE)) %>% \n  pull(mean_cup_points)\n)\n\nsrs_100\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] 82.28910 82.22511 82.44865 81.79030 82.18895 82.28602 81.93398 82.16669\n  [9] 82.44263 81.88150 82.04083 82.01519 82.44579 81.79023 81.98820 82.10662\n [17] 82.16571 81.77722 82.48150 82.33707 82.15068 82.47970 82.04263 82.42812\n [25] 81.99278 82.14045 82.07940 82.34436 82.35406 82.34722 81.97707 82.33519\n [33] 82.27902 82.16744 81.99699 82.34782 82.19429 82.22534 82.04842 81.58609\n [41] 81.69188 82.48827 82.52692 82.34752 82.16955 82.23511 82.48233 81.56188\n [49] 82.31188 81.85571 82.53579 82.66857 82.39353 82.36902 82.46338 82.05015\n [57] 82.28128 82.27105 81.80571 82.27526 82.07414 82.00256 82.08662 82.06444\n [65] 82.04556 81.98812 82.09451 82.15556 82.35158 82.25797 82.42759 81.90053\n [73] 82.12128 82.02128 82.13835 81.87474 81.95338 82.36053 81.77835 82.37669\n [81] 82.42992 82.31857 82.34203 82.46188 82.13120 82.39511 81.81436 82.35496\n [89] 82.31466 82.10842 82.30466 81.74632 82.00835 82.34165 81.77489 82.13857\n [97] 81.93271 81.83812 81.57677 82.13038\n```\n\n\n:::\n:::\n\n\n코드가 다소 난잡하기 때문에 임의표본추출하는 로직을 따로 떼어 함수로 제작하고 이를 마찬가지 방식으로 `replicate()` 함수를 사용해서 동일한 작업을 수행한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrun_srs <- function(proportion = 0.1) {\n  coffee_df %>% \n    slice_sample(prop = proportion) %>% \n    summarise(mean_cup_points = mean(total_cup_points, na.rm = TRUE)) %>% \n    pull(mean_cup_points)\n}\n\nsrs_fun_100 <- replicate(\n  n = 100,\n  expr = run_srs(0.1),\n  simplify = TRUE\n)\n\nsrs_fun_100\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] 82.06579 82.19805 82.32586 82.15820 82.28083 82.35143 82.61331 82.14970\n  [9] 82.44113 81.96286 82.02504 82.14496 82.19564 81.71955 81.85541 82.20955\n [17] 82.18376 82.29902 82.40647 82.21880 81.59015 82.26188 82.04376 82.17797\n [25] 82.33496 82.26932 81.87872 82.67353 81.98301 82.23000 81.93737 81.96759\n [33] 82.03353 82.21113 82.30541 81.65947 81.90489 82.17496 82.00045 82.22962\n [41] 82.40068 82.56759 82.11451 82.35436 82.23511 82.68812 82.34850 82.12203\n [49] 81.97707 82.57504 81.66842 82.39684 82.17293 81.96383 82.35406 81.98233\n [57] 81.97677 82.18902 82.66955 82.17519 82.14714 82.31692 81.85481 81.84662\n [65] 81.97128 81.94789 82.03789 82.24105 81.95564 82.43541 82.16962 82.12925\n [73] 82.12466 82.08286 82.21782 81.79083 82.03759 81.80647 82.46346 81.93241\n [81] 81.92248 81.95797 82.48714 82.10150 82.21376 82.13865 81.95692 81.90293\n [89] 82.13316 82.24008 82.28308 82.02030 82.15165 82.15955 82.21654 82.23308\n [97] 82.11496 82.44331 82.41383 82.38361\n```\n\n\n:::\n:::\n\n\n\n### 표본수 증가 {#calculate-errors-sample-size}\n\n표본크기가 증가할수록 모집단 대표 평균값에 가까이 추정하는 것을 확인할 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nextrafont::loadfonts()\n\nsrs_samp_size <- function(samp_size) {\n  srs_fun_100 <- replicate(\n    n = 100,\n    expr = run_srs(samp_size),\n    simplify = TRUE\n  ) \n  return(unlist(srs_fun_100))\n}\n\nsamp_size_df <- tibble(\n  samp_10  = srs_samp_size(0.1),\n  samp_33  = srs_samp_size(1/3),\n  samp_50  = srs_samp_size(1/2),\n  samp_75  = srs_samp_size(3/4),\n  samp_90  = srs_samp_size(0.90)\n) %>% \n  pivot_longer(cols = everything(), names_to = \"samp_size\", values_to = \"estimation\")\n\nsamp_size_df %>% \n  ggplot(aes(x=estimation, color = samp_size)) +\n    geom_density() +\n    geom_vline(xintercept = mean_population, color = \"darkgray\") +\n    theme_bw(base_family = \"MaruBrui\") +\n    theme(legend.position = \"top\") +\n    guides(colour = guide_legend(nrow = 1)) +\n    labs(x = \"추정값\",\n         y = \"밀도\",\n         color = \"추출비율\") +\n    scale_x_continuous(labels = ~ scales::comma(.x, accuracy = 1))\n```\n\n::: {.cell-output-display}\n![](sampling_files/figure-html/coffee-sample-size-1.png){width=672}\n:::\n:::\n\n\n### 표준편차 {#calculate-confidence-interval-sd}\n\n추정값에 대한 표준편차도 표본크기 변화에 따라 계산해보자.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsamp_size_df %>% \n  group_by(samp_size) %>% \n  summarise(mean_cup_points = mean(estimation),\n            sd_cup_points   = sd(estimation)) %>% \n  mutate(samp_prop = parse_number(samp_size),\n         samp_prop = str_glue(\"{samp_prop} %\")) %>% \n  select(samp_prop, contains(\"cup\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n  samp_prop mean_cup_points sd_cup_points\n  <glue>              <dbl>         <dbl>\n1 10 %                 82.2        0.218 \n2 33 %                 82.2        0.0990\n3 50 %                 82.2        0.0711\n4 75 %                 82.1        0.0422\n5 90 %                 82.1        0.0258\n```\n\n\n:::\n:::\n\n\n## 신뢰구간 {#calculate-bootstrap}\n\n부츠트랩(Bootstrap) 방법론은 모집단에서 나온 표본을 다시 모집단으로 가정하고 표본을 복원추출방법을 통해서 추정하는 방식이다. 부츠트랩 방법론을 통해 추정값은 물론 표준오차도 계산이 가능하다.\n부츠트랩은 크게 두단계로 나누는데 먼저 재표집하는 단계와 통계량을 계산하는 단계로 나눠진다.\n\n부츠트랩을 1,000번 실행해서 얻은 결과를 모집단 평균과 시각적으로 비교한다. 부츠트랩을 통해 계산된 평균은 다음과 같은 특징이 있다.\n\n- 부츠트랩 표본을 통해 도출된 분포의 중심값 평균은 표본 평균과 대체로 동일하다.\n- 그렇다고 해서 부츠트랩 표본이 모집단 평균은 아니다.\n- 즉, 부츠트랩 방법론을 통해 모집단과 모집단에서 추출한 표본집단 사이 발생된 편이(bias)를 보정할 수는 없다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(77777)\n\ncoffee_srs_df <- coffee_df %>% \n  slice_sample(prop = 0.1)\n\n# 1. 부츠트랩 정의\ndefine_bootstrap <- function() {\n  coffee_srs_df %>%\n    # 1 단계 재표본 단계\n    slice_sample(prop = 1, replace = TRUE) %>%\n    # 2. 단계 통계량 계산\n    summarize(mean_cup_points = mean(total_cup_points, na.rm = TRUE)) %>%\n    pull(mean_cup_points)\n}\n\n# 2. 부츠트랩 실행\nmean_cup_points <- replicate(\n  n = 1000,\n  expr = define_bootstrap()\n)\n\ntibble(mean_cup_point = mean_cup_points) %>% \n  ggplot(aes(x= mean_cup_point)) +\n    geom_histogram(binwidth = 0.02) +\n    geom_vline(xintercept = mean_population, color = \"blue\") +\n    geom_vline(xintercept = mean(mean_cup_points), color = \"red\", linetype = \"dashed\")  +\n    theme_bw()\n```\n\n::: {.cell-output-display}\n![](sampling_files/figure-html/calucate-bootstrap-1.png){width=672}\n:::\n:::\n\n\n### 표준오차 {#calculate-standard-error}\n\n표준편차와 표준오차를 다음 수식을 통해 직관적으로 이해할 수 있다. \n즉, 표준편차는 변량에 대한 산포를 측정하는 반면 표준오차는 추정량에 대한 산포를 측정하게 된다.\n\n- 표준편차(Standard Deviation): $\\sqrt{\\operatorname E\\left[(X - \\mu)^2\\right]}$\n- 표준오차(Standard Error): $\\sqrt{\\operatorname E\\left[(\\overline{X} - \\mu)^2\\right]}$ \n\n이를 통해서 표준오차에 표본크기 제곱근을 곱하게 되면 모집단 표준편차를 구할 수 있게 된다. \n\n$$\\sigma_{\\overline{x}} = \\frac{\\sigma}{\\sqrt{n}}$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. 모집단 total_cup_points 표준편차\nsd(coffee_df$total_cup_points)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.686862\n```\n\n\n:::\n\n```{.r .cell-code}\n# 2. 표본 total_cup_points 표준편차\nsd(coffee_srs_df$total_cup_points)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.599749\n```\n\n\n:::\n\n```{.r .cell-code}\n# 3. 표본분포(sampling distribution) total_cup_points 표준편차\nsd(srs_fun_100) * sqrt(nrow(coffee_df) * 0.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.591998\n```\n\n\n:::\n\n```{.r .cell-code}\n# 4. 부츠트랩 total_cup_points 표준편차\nstandard_error <- sd(mean_cup_points)\n  \nsd_population <- standard_error * sqrt(nrow(coffee_df) * 0.1)\n\nsd_population\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.488636\n```\n\n\n:::\n:::\n\n\n\n### 부츠트랩 신뢰구간 {#calculate-standard-error-bootstrap}\n\n정규분포를 가정해서 신뢰구간을 구할 수도 있으나 \n단순히 분위수 함수인 `quantile()`을 사용해서 95% 신뢰구간 상하한을 간단히 구할 수 있다. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(mean_cup_points = mean_cup_points) %>% \n  summarise(lower = quantile(mean_cup_points, 0.025),\n            mean  = mean(mean_cup_points),\n            upper = quantile(mean_cup_points, 0.975))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  lower  mean upper\n  <dbl> <dbl> <dbl>\n1  82.0  82.4  82.8\n```\n\n\n:::\n:::\n",
    "supporting": [
      "sampling_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}